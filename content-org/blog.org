;; -*- mode: Org; org-download-image-dir: "../static/images/posts"; org-download-heading-lvl: 1; org-download-display-inline-images: nil; org-download-timestamp: "" -*-

#+TITLE: Posts
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: blog
#+SEQ_TODO: TODO DONE
#+PROPERTY: header-args :eval never-export
#+OPTIONS: creator:t toc:nil

* Blog
** DONE How to podcast :good:
CLOSED: [2019-04-15 Mon 16:23]
:PROPERTIES:
:EXPORT_FILE_NAME: how-to-podcast
:END:

Here is a TL;DR version:

1. Record using whatever. Even smartphones produce decent sound nowadays. Just make sure to have a consistent volume, i.e. maintain constant distance between your mouth and the phone.
2. Compress to 96kbps mp3 constant bitrate. Or use an online encoder like [[https://pinecoder.pinecast.com/][Pinecoder]].
3. Pick a podcast hosting provider:
   1. [[https://pinecast.com][pinecast.com]]: starts at $5/month with unlimited storage, unlimited shows, basic analytics and website generator.
   2. [[https://simplecast.com/][simplecast.com]]: starts at $15/month per show. Cool player, website generator.
   3. [[https://transistor.fm/][transistor.fm]]: starts at $19/month with unlimited storage, unlimited shows. Limited at 5k downloads per month.
   4. Or one of many others, including [[https://www.podbean.com/][podbean]], [[https://www.libsyn.com/][libsyn]], [[https://fireside.fm/][fireside]] or even [[https://soundcloud.com/for/podcasting][soundcloud]] (probably not the best idea, since the company's finances aren't great)
4. Add your podcast to public catalogs:
   1. [[https://podcastsconnect.apple.com/][Apple Podcasts (iTunes)]]
   2. [[https://podcasters.spotify.com/][Spotify]]
   3. [[https://pocketcasts.com/submit][PocketCasts]]
   4. [[https://play.google.com/music/podcasts/portal/][Google Podcasts]]
   5. [[https://player.fm/importer/feed][Player FM]]
   6. [[https://help.tunein.com/contact/add-podcast-S19TR3Sdf][TuneIn]]

   Some podcast hosting providers can submit your feed to those catalogs on your behalf, but I suggest you do everything manually to keep 100% control over your content.

*** Preparation

This part is very subjective, so I'll just describe my own process.

Since each of my episodes follows a specific topic, I start thinking about it weeks before, just allowing ideas, thoughts and just random pieces of info simmer in my head for hours. I do my best to write down these things, but often just forget them. It's okay. I have learned to let go of "obviously genius" ideas.

I never hesitate to write down whatever comes to mind though. It could be an analogy, a funny phrase, a weird comparison.

At some point I feel ready to jot down the structure. I've been using a large notepad and iPad pro with Apple Pencil, but lately have been enjoying [[https://mindnode.com/][MindNode]] on the desktop. Having a large, tree-like structure fits my way of thinking very well. I just "walk" the tree during recording, trying to visit all the nodes.

*** Recording

There are different levels here.

**** Level 1: Just use whatever.

Your phone or internal microphone of your laptop are /okay/. Not great by any means, but keep these in mind and you'll be fine:
- Pick a quiet spot. Humming noises are the worst (loud fridge, AC, etc.)
- Maintain constant distance between your mouth and the mic
- If possible, record in a smaller room with lots of soft objects to minimize echo. Books, blankets, pillows, curtains reduce echo significantly.

**** Level 2: USB headset

A good and cheap way to improve your sound significantly is using almost any good USB headset. But it /must/ be USB. Those headsets that connect via jack cables are simply using your computer's audio card and the sound might not be much better than with an internal mic.

**** Level 3: USB microphone

USB mics are the combination of "real" microphones and the convenience of USB. You usually don't need anything else, just plug and play.

There are several good choices in this category:

1. [[http://www.rode.com/microphones/podcaster][Rode Podcaster]] (my only mic for 10+ years, produced hundreds of podcasts and videos with it)
2. [[https://www.bluedesigns.com/products/yeti/][Blue Yeti]]
3. Audio-Technica ATR2100-USB
4. Shure PG42-USB
5. Audio-Technica AT2020USB+

**** Level 4: XLR microphone

When you're ready to go "full podcaster", go read [[https://marco.org/podcasting-microphones][Marco Arment's Podcasting Microphones Mega-Review]]. There are audio samples, too.

*** Editing

I edit my podcasts heavily. 60 minutes of recording usually result in about 35-45 minutes of end result. Marco Arment wrote about this in [[https://marco.org/2014/11/29/easy-listening][Easy listening]] and I agree: "you just need to care".

Free and open source [[https://www.audacityteam.org/download/][Audacity]] is more than capable for both recording and editing, but, to be honest, I find it extremely cumbersome and ugly. Once you're serious, I think it's worth to invest into buying and learning a tool like Adobe Audition (my choice) or Apple Logic Pro X.

*** Publishing

Podcast is basically an RSS feed with media files. You can generate it yourself and host mp3 files wherever. If you already have a blog running on Wordpress, it makes sense to just continue using it. On wordpress.com they have a [[https://en.support.wordpress.com/audio/podcasting/][special feature for podcasting]], and if you run your own wordpress instance, [[https://wordpress.org/plugins/seriously-simple-podcasting/][this plugin]] will help you.

It is much easier to use one of the specialized hosting providers:

1. [[https://pinecast.com][pinecast.com]]: starts at $5/month with unlimited storage, unlimited shows, basic analytics and website generator.
2. [[https://simplecast.com/][simplecast.com]]: starts at $15/month per show. Cool player, website generator.
3. [[https://transistor.fm/][transistor.fm]]: starts at $19/month with unlimited storage, unlimited shows. Limited at 5k downloads per month.
4. Or one of many others, including [[https://www.podbean.com/][podbean]], [[https://www.libsyn.com/][libsyn]], [[https://fireside.fm/][fireside]] or even [[https://soundcloud.com/for/podcasting][soundcloud]] (probably not the best idea, since the company's finances aren't great)

Most of them can even generate websites for your shows, although, their design choices are questionable at times.

All of my shows are hosted by pinecast: it's a fantastic value for the money and everything works perfectly fine. Here is my referral coupon code for 40% off for 4 months: =r-a6562b=. Use it at checkout.

*** Questions?

Feel free to email me at contact@rakhim.org, and I'll try to add more info to this guide.
** DONE Easy slides (for me)
CLOSED: [2019-04-21 Sun 14:16]
:PROPERTIES:
:EXPORT_FILE_NAME: easy-slides-for-me
:END:

As a software developer, at some point you discover simple slides and presentation generators: Markdown-to-PDF/HTML converters, Emacs extensions, LaTeX exporters, VIM plugins, etc. The idea makes perfect sense, because:

1. I don't want to use PowerPoint or Keynote.
2. I don't want to use the mouse.
3. I want plain text.
4. I want simplicity.

You can create presentations without leaving your favourite editor or command line. But unfortunately, the majority of the results are just text with an occasional poorly positioned funny GIF (that didn't load because wifi is down).

I completely understand the desire to make things as simple as possible and forget about clunky GUI-based presentation software. I don't like them either, and yeah, I'd love to be able to do things from the comfort of my text editor. You might say that text is mostly enough, animations and other flashy effects don't contribute to the value.

But I argue that animations, visualizations and transitions are tools, and like any other tool, they add value when used correctly. By sticking to text-only slide generators, you disregard a whole set of tools and potentially a whole set of problems they might help solve.

A title flying out from the corner probably doesn't do any good, the effect has no meaning. But if you want to explain something non-trivial (not to you, but to your audience), consider using /something/ to illustrate your point or even just to focus viewer's attention. It's not about animation or burning flames effect, it's about /anything/ above the typewriter in the pyramid of technology.

Dimming. Colors. Shapes. Transparency.

Computer science is full of complex ideas, multiple levels of abstraction, non-obvious connections and relations. It pains me to see whole presentations, thick books and long manuals with essentially zero visuals, zero attempt to convey an idea with something other than text.

Your slim Markdown-to-PDF converter serves one purpose: make /your/ life easier. Nothing wrong with that. But there are also viewers who might benefit from a more detailed visual presentation. Of course, not all viewers would. For many, text and your speech are more than enough, after all, many of us became programmers because of the ability to understand complex, abstract, non-visual ideas to begin with. This is where lack of diversity starts from, I believe. We filter out people by their adaptability to certain styles and formats of explanations. We filter out people by their learning medium.

/You need a cartoon to understand closures? Good luck. Maybe, programming isn't for you?../

Now, I understand that it takes time, and you might just not have enough of it. I am not bashing these wonderful tools and not saying you /must/ produce visuals and animations. I just wanted to remind you that plain-text presentations are compromises. It's absolutely fine to mindfully and intentionally make compromises.
** DONE Rethinking Twitter :good:
CLOSED: [2019-05-15 Wed 17:51]
:PROPERTIES:
:EXPORT_FILE_NAME: rethinking-twitter
:END:

*** Good old days

Twitter is the only social media I've ever used. Sure, I had accounts on other sites, but was never really engaged elsewhere. I couldn't understand all those "facebook addiction" stories, honestly. Facebook was always extremely boring, while Twitter was always exciting.

From the beginning, it was a perfect, geeky, simple thing that is kind of hard to explain. Just a stream of short thoughts. Cool links. One liners. A public chat room.

I joined Twitter in 2007. Woah, 12 years ago! I was studying in a university, and smartphones weren't really a thing yet. This is totally a "back in my days" kind of rhetoric, but hell, that Twitter was nice.

Most people didn't have a Twitter account. Because it's weird, what's the point? So, like other internet communities, Twitter started as a selected group of weirdos, acting constantly amazed about the fact that they're all here. Tweeting.

The timeline was chronological, and the world seemed ordered. It was more like RSS than like Facebook or TV: you could only see the people you explicitly subscribed to. Never an unknown face in your timeline. Retweets weren't a feature, it was just a thing people did: copying a tweet and putting "RT" in front of it. I think it's a better strategy overall: if you retweet something this way, you put your face on the message, you own it now. So, the value of retweets was higher, nobody wanted to copy every mildly interesting thing.

There were no likes, this added sugar of engagement and interaction. You like something? Well, say it. Tell it to the author, do a retweet with an encouraging comment. Do something you'd do in real life.

Twitter was allowing people to communicate via a digital medium. Not communicate in a new digital way.

And Twitter wasn't like TV.

*** Outsourced schizophrenia

A HackerNews user had [[https://news.ycombinator.com/item?id=16292024][put]] it nicely:

#+BEGIN_QUOTE
I think the problem is that Twitter is a platform for evolutionary selection of slogan-based-dialog. I kind of imagine two armies standing across a battlefield from one another carefully deciding which volley of pithy digs to throw at one another.
#+END_QUOTE

Yeah. It's like switching TV channels every 5 seconds.

[[https://adambrault.com/blog/i-quit-twitter-for-a-month][This article]] had hit home hard for me. I'll just include a few quotes:

#+BEGIN_QUOTE
There are people you know whose voice you can hear in your head [...], or people who you even consult with in your head for wisdom ("What advice would my dad give here?") [...]

...it can be a huge mental lease we're signing when we invite a few hundred people into our Twitter life. To some degree, it is choosing to subject ourselves to thousands of ads throughout the day, but ones that come from trusted sources we care about, so they're actually impactful.
#+END_QUOTE

Yes! And especially today, thanks to both natural and artificial (algorithmic) selection, these short ads are hyper-optimized for stickiness and virality.

#+BEGIN_QUOTE
We've surrendered a massive amount of mental and emotional energy without making the explicit choice to do so--it's simply imposed on us by subscribing to the channel and checking it.
#+END_QUOTE

The worst part is that nowadays you see a chaotic stream from people you /haven't/ explicitly subscribed to: retweets, liked and promoted tweets, ads, etc.

#+BEGIN_QUOTE
Mentally, we just aren't capable of simultaneously empathizing with hundreds of people--let alone thousands or millions. The result is we either build up a calloused, jaded, or cynical defense against empathy or find a way to block out more.
#+END_QUOTE

I can hardly manage interacting with a single person for more than a few hours, let alone with hundreds, even via virtual channels.

This one describes me very well too:

#+BEGIN_QUOTE
I'll admit: I'm an annoyingly oversensitive person. I do believe this is both a strength and a weakeness. [...] I also have a tendency to listen carefully to any criticism or disagreement I hear, internalize it, reflect on it, and evaluate it, then conclude some thought on it. Until I do that, it just sort of hangs there in my head. The degree to which it dominates my headspace is largely a question of how much it impacts me.
#+END_QUOTE

If nothing else, I want you to consider this quote:

#+BEGIN_QUOTE
[...] Twitter is outsourced schizophrenia. I have a couple hundred voices I have consensually agreed to allow residence inside my brain.
#+END_QUOTE

I assume not everyone is like that, and not everyone experiences social media this way. But Adam, the author of that post, does. I do too.

His essay is fantastic, really:

#+BEGIN_QUOTE
I've realized how Twitter has made me break up my thoughts into tiny, incomplete, pieces--lots of hanging ideas, lots of incomplete relationships, punctuated by all manner of hanging threads and half-forked paths.
#+END_QUOTE

*** Change

But Twitter has been very beneficial to my career. With a few thousand followers, links to my projects had consistently brought me hundreds of hits, readers, clients. This is my strategic failure: I haven't been working on maintaining an independent outlet for my audience, a newsletter or a consistent blog. For more than a decade, Twitter has been the main channel of distributing my work.

So, I decided to make a few changes and conduct an experiment.

1. Unfollow everybody. No more timeline.
2. Tweet via an app like Buffer, without opening Twitter itself.
3. Open Twitter and reply to mentions only on weekends.
4. Invest energy into maintaining a consistent blog and a personal newsletter. You can subscribe to the newsletter [[https://buttondown.email/rakhim][here]] or with a form below:

#+BEGIN_export html
<form
  action="https://buttondown.email/api/emails/embed-subscribe/rakhim"
  method="post"
  target="popupwindow"
  onsubmit="window.open('https://buttondown.email/rakhim', 'popupwindow')"
  class="embeddable-buttondown-form"
>
  <label for="bd-email">Enter your email</label>
  <input type="email" name="email" id="bd-email">
  <input type="hidden" value="1" name="embed"/>
  <input type="submit" value="Subscribe" />
</form>
#+END_export

I will maintain this system at least until the end of 2019 and we'll see how it goes.

TWEET THIS NOW!
** DONE 80-characters limit for text is wrong :good:
CLOSED: [2019-05-30 Thu 12:27]
:PROPERTIES:
:EXPORT_FILE_NAME: 80-char-is-wrong
:END:

I believe the 80-characters (or any other number) line limit for text to be wrong. Not archaic or irrelevant, but wrong. It violates a fundamental idea of computer science: separating layers of abstraction.

Not talking about code today, although, I don't think a strict limit is a good thing there either, for other reasons. I'm talking about human text.

Many programmers stick to the 80-characters line length limit while writing documentation, emails, etc. Emacs and other editors even have special modes or plugins for automatic hard wrapping.

Often, results look like so:

[[/images/posts/email.png]]

Without hard-wrapping, this email had a chance to look normal everywhere. Any app can interpret and present it in any way. With hard-wrapping though, this email can only look normal in certain conditions. Namely, a certain lower limit for window width.

Imagine joining a web project and seeing a =users= database table with values like =<strong>Jason Norwig</strong>=. Your reaction might include profanity, because mixing data and presentation is wrong. Person's name (data) and its presentation (HTML) are different layers of abstraction.

Hard-wrapping lines by inserting =\n= symbols where they don't have any semantic meaning is the same sin. The whole character return thing was relevant in a context where data was inseparable from presentation: typewriters and paper.

A key argument for hard-wrapping goes something like this: "modern screens are too wide, it's uncomfortable to read long lines". But modern screens come with modern apps, which can handle presentation to your preference. By modern I mean "developed after the '70s". Text editors (including vim and Emacs) have been able to soft-wrap lines at arbitrary comfortable column for decades.

If your text presentation tool can't present text to your preference, consider replacing it. Moving this responsibility into data itself is not a solution.

#+BEGIN_export html
So can we please<br>
stop doing this<br>
to each other.<br>
#+END_export
** DONE Bicycles and Love :good:
CLOSED: [2019-07-27 Sat 11:47]
:PROPERTIES:
:EXPORT_FILE_NAME: bicycles-and-love
:END:

I love bicycles.

The first memories I have are bike-related. The best ones are, too.

#+DOWNLOADED: file:/Users/rakhim/Downloads/my_first_bicycle.jpg @ 2019-07-06 15:45:39
[[file:/images/posts/Bicycles_and_Love/my_first_bicycle.jpg]]
/My first bicycle was a tricycle/

I don't remember a time I didn't bike. Bicycle means freedom.

My first serious bicycles, the ones that let me explore the city, were old, steel soviet tanks. They were simultaneously indestructible and always broken.

My friend Eugene and I spent summers biking around town, forests and river valleys. It was awesome.

#+DOWNLOADED: file:/Users/rakhim/Downloads/bikes_river.jpg @ 2019-07-06 15:47:48
[[file:/images/posts/Bicycles_and_Love/bikes_river.jpg]]
/Eugene riding away, my bike in front/

Those bikes were all-purpose vehicles. Well, at least for us they were. Pavement, gravel, sand, water, whatever. They go where we go. They were simple and stupid, and I loved that. No speeds, no hand brakes.

I used to live with my grandma until I was 13. Her apartment had a narrow corridor connecting the entrance to the room, and I can't imagine it without a bicycle. It was always there, and when it wasn't, I wasn't home. Out biking god knows where.

I had a dream of driving a city bus, so quite often I spent hours biking along the bus routes, stopping at bus stops, emulating a bus. An old pen was diligently placed inside the handlebar, sticking about 2 inches outwards: it was my fake turn signal lever. I had to make the turn signal clicking sound myself, of course.

Then I moved to Canada. My next bike was a pretty cool steel Schwinn I got as a gift from my host family in Ottawa. Bicycle freedom had suddenly expanded. Now I could ride to another province where people speak a different language and traffic lights are horizontal. I could bring my bike on the train and get further than ever. I could disappear into the city and nobody could find me.

#+DOWNLOADED: file:/Users/rakhim/Downloads/schwinn.jpg @ 2019-07-06 15:53:12
[[file:/images/posts/Bicycles_and_Love/schwinn.jpg]]
/I didn't appreciate this bike enough. I wish I could get that frame back.../

Several random used bikes later I decided I'm ready to spend serious bucks and try road biking. With 1000 Canadian dollars in hand, I walked into a bike shop in western Ottawa and got myself a beautiful aluminium Trek 1.1.

Freedom was reinvented once more. With this light, fast bike I could go further than ever before. First 100 km ride was a revelation. Then 350km in 2-day group event. Then 500km in three days. Then more than a 1000 km in a week across multiple provinces to see the ocean.

#+DOWNLOADED: file:/Users/rakhim/Downloads/trek.jpg @ 2019-07-06 17:42:58
[[file:/images/posts/Bicycles_and_Love/trek.jpg]]
/At the end of my long trip to see the Atlantic Ocean, New Brunswick, Canada/

I was in love again.

I was about to finish my computer science degree and was feeling somewhat [[https://rakhim.org/2018/10/dazed-depressed-defunct/][down]] at times. That bike was the best thing in my life.

Biking and computer science made perfect sense to me. Both are about efficiency. Both are tools, but at the same time fun in and of themselves. Both let you be alone.

They let you disappear into a vast domain and get lost.

After moving from Canada to Kazakhstan, I stopped biking. It took me almost 5 years to re-ignite the passion.

After moving to Finland, I decided to try a single-speed and got a pretty Swedish Stålhästen Sport fixed gear bike with a flip-flop hub. Fixed gear is not my cup of tea, so I flipped the wheel and started discovering the Helsinki area.

It was pretty sexy.

#+DOWNLOADED: file:/Users/rakhim/Downloads/fixie.jpeg @ 2019-07-06 17:51:08
[[file:/images/posts/Bicycles_and_Love/fixie.jpeg]]

But alas, we weren't for each other. We just didn't click. A bicycle is an intimate object for me, along with backpacks and computers. I can't just have one, I must love it. So I sold it to someone who, hopefully, loved it.

And got myself a cyclocross Kona Rove Al 2015.

#+DOWNLOADED: file:/Users/rakhim/Downloads/kona_rove_al.jpeg @ 2019-07-06 18:05:59
[[file:/images/posts/Bicycles_and_Love/kona_rove_al.jpeg]]

The relationship with this one was complicated. I loved it and sometimes hated it.

I loved my Kona because it was very comfortable, fast and looked very cool. Its brownish color was a perfect fit for the forests and fields I took it to. Disc brakes — first for me — made me more confident on narrow descents and uneven terrain.

But I didn't love the maintenance. It was equipped with the cheapest components. Decent, but not awesome. Shimano Claris groupset and mechanic disc brakes were never perfect. The bike was never perfectly tuned, never perfectly silent. And I'm ashamed to admit, but I'm a crappy handyman when it comes to bikes. Actually, I'm a crappy handyman in all areas where "undo" is not an option, but I'm particularly bad with bicycles. Derailleur adjustment and disc brake calibration are black magic to me. Hours of sweat and profanity and I end up with a subpar configuration. It works and it's fine, but it's just not very good. Then I say "screw this!" and bring the bike to a mechanic.

By the way, good bike mechanics are pretty expensive in Finland.

I've later learned that better groupsets and hydraulic brakes (or at least the hybrid dual-piston ones) are so much better, and I honestly almost convinced myself to spend two grand on a /very good bicycle/. Because then I will ride more, right?

Kona Rove Al was my bike for three good seasons, but the furthest I took it was a 120 km one day ride. It never saw other regions of the country even. We weren't too adventurous together.

This summer, after another failed attempt to eliminate 100% of the disc brakes noise, I decided to say goodbye to Kona and look for something new.

A romanticized and, perhaps, irrational desire to simplify struck me again. What is the simplest bicycle possible? Single speed with coaster brake. I love handbrakes, so, rim brakes then. But I wasn't sure I could do single-speed again. I love my knees.

Then I discovered internal hubs. They look and feel like single-speed from the outside: no derailleur, no cable slack. My girlfriend and I got ourselves small folding bikes with Shimano Nexus 3-speed hubs and they are very nice. Simple, reliable, solid.

#+DOWNLOADED: file:/Users/rakhim/Downloads/nexus.jpg @ 2019-07-06 18:32:03
[[file:/images/posts/Bicycles_and_Love/nexus.jpg]]

There also exist 7-speed Nexus hubs, but I haven't tried one. They are pretty heavy and it's a pain to install them with dropbars.

Turns out, there are also automatic hubs! Woah! Extremely curious, I got myself an old Fixie Inc. Floater with Sram Automatix 2-speed automatic hub.

#+DOWNLOADED: file:/Users/rakhim/Downloads/fixie_floater_sram.jpg @ 2019-07-06 18:37:20
[[file:/images/posts/Bicycles_and_Love/fixie_floater_sram.jpg]]

The experience is... interesting. You just start pedaling and at about 15 km/h the gear changes automatically. It's pretty solid, no wobble or anything. It's like you're suddenly teleported into higher gear. This shift point it ridiculously low though. It was pretty easy to disassemble the hub and change the shift point by unwinding a tiny metallic spring ([[https://bikesfornoreason.blogspot.com/2014/01/sram-automatix-2-speed-hack.html?m=1][here's a good description]]).

At first, it seemed like a good compromise. Almost as simple as a single-speed, but the second gear allows to keep a sane cadence at higher speeds. Unfortunately, the hub is not as isolated from the outside world as other internal gear hubs, so it will require some maintenance.

I took it on multiple rides and just didn't love it. What a picky, delicate flower I am.

And then, completely by chance, I had a chance to ride Bombtrack Arise. A single-speed, steel gravel bike.

Yes! It made me smile!

#+DOWNLOADED: file:/Users/rakhim/Downloads/bombtrack_arise.jpg @ 2019-07-27 11:30:22
[[file:/images/posts/Bicycles_and_Love/bombtrack_arise.jpg]]

I'm not a fast rider, so when it comes to gearing, comfortable climbing is more important to me than going fast. Finding the perfect ratio for a single-speed takes time and lots of cogs, but this bike came with what seems to be the perfect ratio for me: 42 teeth chain ring and 17 teeth rear sprocket. With 28" tires, it yields 69 gear inches, which works very well for the steepest hills in my area and is good enough for descents.

This [[https://www.bikecalc.com/fixed][handy bike calculator]] helps to figure out the good ratio for a given cadence and speed. For my new bike, 90 rpm produces 28.4 km/h, and the high cadence of 130 rpm yields 41 km/h.

Single speed forces me to be more disciplined and think ahead. I can't just attack a hill on a granny gear anymore, I have to save as much momentum as possible. At the same time, this creates ultimate freedom. I don't think about optimal gearing, I am always in the +wrong+ right gear.

Steel frame is lovely and comfortable, it feels softer, yet more confident. The simplicity of not having so many extra things inspires almost a zen-like feeling. Oh, and it's quiet. No chain slap.

I am yet to take the Bombtrack on a truly long ride, and it might not be as peachy as I describe. But so far, with about 250km behind, I remain in love.

Find a bike you enjoy, it will make you happier.
** DONE Process of Learning :good:
CLOSED: [2019-07-29 Mon 17:24]
:PROPERTIES:
:EXPORT_FILE_NAME: process-of-learning
:END:

A process of learning is analogous to an attempt of building a three-dimensional model from two-dimensional photos.

You approach a new area of knowledge. You know nothing at all. You stumble upon a first piece:

#+DOWNLOADED: https://rakh.im/images/posts/lm_1.jpg @ 2019-07-29 16:37:33
[[file:/images/posts/Process_of_Learning/lm_1.jpg]]

That's more than nothing, but still very little. You don't understand it. At best, you're able to make a few uncertain assumptions.

Beginners often seek good book recommendations. They would google a top-10 list and then ask "which one should I start with?". The answer is almost always "it doesn't matter". Start with /any/ non-shitty book. One book alone would not provide enough data to build a good model anyway. If you want to really understand something, you'll have to read several books, listen to different people, try various approaches. Nobody knows what's going to work best for a particular person. Each model building machine is unique. The starting order of feeding it data is not very important, unless that information is truly harmful.

("What is harmful" is a topic for another discussion, and I by no means argue that finding non-harmful books is an easy task. In fact, I'd call many popular programming books harmful, especially when it comes to teaching the basics of programming with Java. So, at least minimize the potential harm by not focusing on a single book.)

Another basic book will provide a different view:

#+DOWNLOADED: file:///Users/rakhim/Downloads/lm_2.jpg @ 2019-07-29 17:03:04
[[file:/images/posts/Process_of_Learning/lm_2.jpg]]

You still can't understand it. But keep going, and at some point you'll arrive at a single complete picture.

#+DOWNLOADED: file:///Users/rakhim/Downloads/lm_3.jpg @ 2019-07-29 17:04:04
[[file:/images/posts/Process_of_Learning/lm_3.jpg]]

This tells you more than before, you can even make some conclusions or reason about certain aspects of the object. But you don't have a complete model yet, one 2D picture is not enough. Your brain haven't met such objects in the past, there's nothing to cling on to. This is why it's essential to have various sources of information: other books, people, lessons, different mediums.

New pieces keep emerging, and it's disconcerting. They don't seem to make any sense, this puzzle feels broken.

#+DOWNLOADED: file:///Users/rakhim/Downloads/lm_4.jpg @ 2019-07-29 17:06:53
[[file:/images/posts/Process_of_Learning/lm_4.jpg]]

This is the toughest stage of the learning journey. Often, any hope is lost. Disconnected pieces provoke the feeling of meaninglessness. You can't see the big picture.

> I think I understand each individual topic, but have no idea how they are connected. And why did I learn all that. Nothing makes sense...

But if you keep going, soon you'll get to another full picture:


#+DOWNLOADED: file:///Users/rakhim/Downloads/lm_5.jpg @ 2019-07-29 17:08:57
[[file:/images/posts/Process_of_Learning/lm_5.jpg]]

Interesting! A completely different point of view. Same object, new aspects. A complete 3D model is still impossible to deduce, but there's more space for assumptions. Having multiple pictures increases the chances of seeing /something/ familiar. It's a new topic alright, but topics are rarely completely isolated from the universe.

A few more pictures and you get a pretty accurate model.

#+DOWNLOADED: file:///Users/rakhim/Downloads/lm_6.jpg @ 2019-07-29 17:11:00
[[file:/images/posts/Process_of_Learning/lm_6.jpg]]

The first picture was extremely valuable, but each new picture brings less and less valuable data. At some point you have a decent model in your head, so that new pictures don't give you anything new.

This analogy helps me learn new things. I try to remember the following:

1. At first, everything is interesting and easy. The first picture gives a lot of data at once. This is the pleasant stage.
2. In the middle motivation will decrease. That's okay. Keep getting data and trust the system.
3. Do not focus on a single picture. Maybe, in order to understand it you need another picture first.
4. At some point, notice the diminishing returns of new data. Consider increasing the area of study.
** DONE Be Wary of Self Described Benefits
CLOSED: [2019-09-03 Tue 18:06]
:PROPERTIES:
:EXPORT_FILE_NAME: be-wary-of-self-described-benefits
:END:

Picking a university was one of the main tasks in the last year of high school. That and exams. I wasn't sure what to study and which place to pick. I had no idea /how/ one can make these choices. There weren't too many resources available at the time. So, a lot of us relied on promotional info provided by universities themselves.

The one I ended up in was called SDU. Its official description says: "SDU is a secular higher educational institution located in Kaskelen, near Almaty."

It was the only university that actually claimed to be secular. That's good, right? I had no interest in studying at a religious institution. Secular is good.

Turned out, it wasn't very secular. No, we didn't study Holy Texts. Officially, nothing religious was going on. But the Islamic values did indeed feel affecting the policies and decisions everywhere. The dormitories for males and females were separate buildings in different neighborhoods. I had actually never seen the women's dormitory, nor had any male student around. The girls just went to a mysterious place every evening. A large proportion of students held a religious fast (Ramadan). Several instructors gave bonuses to fasting students. So I had to work harder to get the same grade because I was being secular at a secular university.

I dropped out after 4 months. Thank /God/.

Later, I started to notice this pattern. Often, people, communities, companies and even countries seem to blindly put positive descriptions out. As if they /wanted/ others to notice.

It becomes very clear in case of countries. Here are some famous authoritarian regimes:

- Democratic People's Republic of Korea
- Democratic Republic of the Congo
- People's Republic of China
- People’s Democratic Republic of Algeria
- Federal Democratic Republic of Ethiopia

Right.

So I learned to be wary of self described benefits. It's kind of obvious and silly once you think about it.

Yours truly,
not passive aggressive at all, Rakhim.
** DONE User Is Dead :good:
CLOSED: [2019-10-22 Tue 10:51]
:PROPERTIES:
:EXPORT_FILE_NAME: user-is-dead
:END:

/User is dead. User remains dead. And we have killed him. How shall we comfort ourselves, the developers, the designers, the growth hackers? What was holiest and the final judge of all that the world has yet owned has bled to death under our a/b-tests and new features. Who will wipe this blood off us? What garbage collector is there for us to clean ourselves? What conference of atonement, what disruptive technology, what sacred meeting shall we have to invent? Is not the greatness of this deed too great for us? Must we ourselves not become users simply to appear worthy of it?/

By saying "God is dead" Friedrich Nietzsche tried to express the fear that the decline of religion and the rise of nihilism would plunge the world into chaos.

Whether you believe that people /require/ an external source of morality, or you accept the numerous philosophical and scientific arguments for intrinsic morality in behavior of complex animals, the fear remains relevant. The fear is not necessarily about God or religion, but about a moral compass, or lack thereof.

My arguably tasteless rewrite of Nietzsche's passage expresses another fear, which, I sincerely hope many software developers share. For a long time, we had an external source of morality in software development. *User.* Simultaneously ephemeral stick figure of UML diagrams and a very real human, a friend, a colleague. The goal, the point, the final judge of success. Your product either satisfied the user or failed. Your software may occasionally have charmed User, but don't be fooled, you are but a servant.

"Move fast and break things", "disruption" and "growth" have killed User. No more do we try to offer invisible quality. Instead of software that blends into background by virtue of its non-obtrusive robustness and simplicity, we aspire to create The Product Experience. The first pleases User. The latter pleases Shareholder.

The Holy Texts are forgotten or, worse, perverted. Apple's famous Human Interface Guidelines ironically describe the many ways in which modern Apple products /do not behave/. The Agile manifesto became The Certified Agile Coach Training Program and a cargo cult. The very first principle of the Agile Manifesto states:

>Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.

How many of us feel this during another a/b-test-driven, metric-based sprint?

The 7th principle is:

>Working software is the primary measure of progress.

An honest, but naive assumption that we all share a similar criterion for "working". Turns out, the height of the bar is inversely proportional to the proximity of another funding round. By the 90s standards, a lot of today's software is just defunct.

When User dies, only Beta Tester remains. Beta Tester is not human. It's an expendable tool, a lab rat, a database record.

What can we do as developers? Honestly, I don't know. Coming up with a manifesto, a set of principles, another guideline — it all seems futile now. The problem isn't that we forgot about User. We just collectively adapted to the new definition of normal. Breaking changes are normal. Updates for the sake of updates are normal. The house is on fire, but this is normal.

What can we do?.. /"Must we ourselves not become users?"/
** DONE For Google, you're neither the consumer nor the product. You're a data point. :good:
CLOSED: [2018-09-26 Wed 14:24]
:PROPERTIES:
:EXPORT_FILE_NAME: you-are-a-data-point
:END:

In light of recent changes to Google Chrome, many forums have filled with bitter discussions. Here are just a few:

- [[https://twitter.com/ctavan/status/1044282084020441088][Chrome 69 will keep Google Cookies when you tell it to delete all cookies]]
- [[https://news.ycombinator.com/item?id=18052923][Why I’m done with Chrome (HN discussion)]]
- [[https://news.ycombinator.com/item?id=17942252][Using Gmail? You will be force logged into Chrome]]

At some point someone inevitably says:

> *For Google, you are not the consumer. You are the product.*

But companies usually care about their products, protect them, try to improve their state.

If I were a product, Google would do its best not to destroy me. They have invested a lot of resources into this product, so why risk it by making baffling changes to both privacy and user experience? If I stay happy with Google's offerings, I keep being the perfect product: I can be mined for data and "sold" perpetually.

Clearly, Google doesn't care about me personally. And how could it? There are billions of people just like me who use their services every day.

Maybe we should stop thinking we're "Google's product" and start thinking we are *data points in endless experiments*.

*** You're Data Point

What does it mean to be a data point?

1. Your personal issues don't matter.
2. You, alone, are not valuable.
3. You can be easily replaced.

While this is a gloomy oversimplification, I believe it's important to recognize the general idea.

*** You're playing a role in some "user story"

When you pretend you're the consumer, you think in terms of goods and services, and a simple two-way relationship. This leads to disappointment every time a breaking change comes in or a service shuts down altogether.

In reality, you are playing roles in many "user stories" and experiments, without knowing it and without knowing what those roles actually constitute.

#+CAPTION: Product manager's bedtime user story.
#+ATTR_HTML: :class wide
[[/images/posts/google_data_point/user_story_time.jpg]]

Few weeks ago Google announced that Inbox will be closed next Spring. Many ask the heavens "Why would Google kill Inbox?! I've been using it every day and all my friends have!"

I bet it was a successful experiment for Google: by using the app, you've generated a lot of important information, helped them learn useful patterns and god knows what else. They are not killing it because it failed as a consumer product, it was never intended to be one. They are not killing it because not enough people used it, or used  not extensively enough. Quite the opposite.

They are not really "killing" a product, they are finishing up an experiment.

Just like scientists don't "kill" good experiments, even though the mice might ask the heavens "why would they kill this maze?! I've been running in it every day and all my friends have!"

#+CAPTION: Google shuts down another product.
#+ATTR_HTML: :class wide
[[/images/posts/google_data_point/mouse_maze.jpg]]

Of course, not all Google's products are experiments. This isn't a binary thing though: some products are clearly (in hindsight) temporary experiments, some are core things that rarely change, but the majority of apps and services are somewhere between. And you never know what games are you in.

*** You are punished for being a good data point

If you truly use Google's products extensively, you are statistically more likely to be punished for that. For example, if you haven't willingly participated in the experiment called "Google Inbox" and just ignored their promotion, its shutdown won't affect you negatively. Actually, it will affect you positively: the results of this experiment will help improve the feature set of Gmail, the service you're probably using.

But if you were a good data point[fn:1], and invested a lot into Inbox' features, you'll receive a punishment. Your workflow — and an important one! — will just be disregarded.

"We will incorporate many features of Inbox into Gmail" is a weak consolation when in one day your whole email experience just shuts down.

*We have to understand this fundamental change of the relationship between companies and users*. The main focus for tech giants is growth, which requires data, which requires experiments. The more we participate in data points generation, the more likely we'll be burned.

Compare this to the old and straightforward concept of "product X is popular, therefore product X will be kept on the market".

But why? Don't they /want/ to have popular products? Well, yes, but...

*** Your personal metrics aren't aligned with theirs

We might think that "popular is good", but for Google often "more data points is good", because that's *the real resource* that allows them to grow. Ten different products, launched and shut down sequentially, is a better source of data points than one, long-lived and stable service.

We do not and cannot know what is important in any given experiment. Heck, we can't even know the scopes and the limits of them. That's the point of having experiments!

But one thing is certain: our values and metrics rarely align with theirs. Because, as a user, I don't really care about company's growth.

You might say "Yeah, obviously! Their goal is profit, nothing new here!". But it's different this time. All businesses' end goal is profit, that's capitalism, nothing wrong with that. The problem is in the hidden, implicit nature of the relationship. We don't really know the deal! What can we do? What can we be sure of? What are our rights? What are their responsibilities?

*What exactly is the deal?!*

*** You're a renewable source

Google itself uses your data to grow, but it also uses it for to make money by targeting ads. That's what people mean when they say "Google sells your data!" and that's where "you're the product" rhetoric comes from.

But it's not like Adidas wants /my data/. Or yours. They want a large group that satisfies certain parameters.

#+CAPTION: A company sells your data.
#+ATTR_HTML: :class wide
[[/images/posts/google_data_point/selling_data.jpg]]

Of course, companies don't get a .zip-file with names and addresses. They receive the ability to show certain ads to certain people. Google doesn't /sell/ your data, they /sell access/ to your eyes and ears. So, you're not just a product, you're renewable source of products. Your tastes and needs change over time, you can be targeted over and over.

This denies any sort of hope one might have about companies caring about their products. They do, just not about individual items or individual producers. Apple doesn't care about any particular iPhone device or any particular worker at their Chinese factory.

*** But I pay them money!

The third aspect is "Google and paid services". Google sells a lot of things directly, and this /must/ be a "consumer-producer" scenario, right?

Yeah, no.

Google recently increased the fees for Google Maps API about 1400%. This kind of increase means one of the two:

1. Previous pricing model was inaccurate.
2. New pricing model is inaccurate.

Were they losing money before to conquer the market? Or did they just decide to make a buttload of cash using the conquered market? Either way, the problem is the same: *we had no idea what the deal is.*

Another example is Google Cloud, a platform used by many large businesses. You can [[https://medium.com/@serverpunch/why-you-should-not-use-google-cloud-75ea2aec00de][lose everything]] in 3 days and deal with a pretty bad support even though you're paying client.

> Not to mention the lack of visibility in changes - it seems like everything is constantly running at multiple versions that can change suddenly with no notice, and if that breaks your use case they don't really seem to know or care. It feels like there's miles of difference between the SRE book and how their cloud teams operate in practice. ([[https://news.ycombinator.com/item?id=17431813][comment in a relevant discussion]])

Are they underfunded? Is their goal to make a reliable platform or is it something else? What do they take into account when they make changes? We have no idea.

*** This is not just Google

It's easier to talk about Google because they seem to be the biggest company in this area (or ever). But this is the reality for a lot of businesses, not necessarily in the advertisement industry.

Once the company is large enough, all customers become data points. This is okay in principle. I can live with that, as long as I understand it. This is a question of honesty.

If Google said upfront:

> We're launching this new product X, but it's an experiment. We'll work on it for at least 5 years, but can't guarantee anything after that. We might shut it down with short notice. Would you like to participate?

Then there would be no point in complaining. That's a fair deal. Of course, this kind of frankness wouldn't help Google. It's like telling the participants of a sociological experiment about all details of said experiment. It poisons the data. Scientists want unsullied results.

#+CAPTION: I hope I'm not sued for this...
[[/images/posts/google_data_point/google_inbox.jpg]]

If Google said upfront:

> We're giving you a lot of awesome products free of charge. But we'll collect as much information on you as possible, and if we'll keep changing the services and terms to collect more data. We will use this information to target ads and maybe do something else. Would you like to participate?

That's a fair deal too. You are /free/ to give up anything, as long as you understand what's going on. Of course, this kind of message doesn't survive the path from Terms of Service to The Marketing Department.

But you always read ToS, right?

All that is obvious in hindsight (in those forums, there's always at least one guy who says "what did you expect?"), but we have to learn to infer these things from the business models. This is not our jobs, but that's the reality. *We have to understand all the implications of these new, weird businesses*.

Every time you see a new startup, new app, new service with some interesting features, and it's clearly not a simple "I pay, you provide" kind of deal, *beware*. What are the implications?

*** Conclusions

Let's summarize:

- Growth, not simple profit generation is the main focus.
- Growth requires data. Experiments, changes and seemingly weird decisions generate data.
- For Google and many tech giants, you are a data point.

And as the result:

- *We no longer interact with businesses.* We interact with the top layer interface of a multi-layered, non-obvious system built with implicit, vague rules.
- Never before were users' and companies' goals so irrelated to each other.
- We're constantly *playing games* we're not aware of.
- We have to learn to understand the implications of this.

*** Final words

Not all is bad. This symbiosis can be very benificial for all parties. We can explicitly play roles of consumers, products and data points at the same time, knowing what's happening and being in control. Companies can play whatever games they need to play with us.

Extremely relevant ads and extremely personalized user experiences sound pretty good to me, all the creepiness aside.

Legislation will never catch up in time, so we have to take things into our own hands and learn to live in this brave new world.

[fn:1] Rather, a generator of myriads of data points, but "data point" sounds more inhumane and humiliating, so I'll stick to this term for dramatic purposes.
** DONE RE: Software disenchantment :good:
CLOSED: [2018-09-17 Mon 23:57]
:PROPERTIES:
:EXPORT_FILE_NAME: re-software-disenchantment
:END:

Nikita just published [[http://tonsky.me/blog/disenchantment/][Software disenchantment]], and here is my rant-y reply. Please, read his post first.

TL;DR: I agree with Nikita and I am equally frustrated with the current state of the industry. We started [[https://grumpy.website/][grumpy.website]] together, after all. But I don't believe that situation will significantly improve until the general public's standards increase. Along with the responsibility to make better software, we have a responsibility to educate the public, so that they don't get used to the idea that computers suck.

---

>Would you buy a car if it eats 100 liters per 100 kilometers? How about 1000 liters? With computers, we do that all the time.

The thing is — yes, people would. It all comes to the micro economic level. If a car eats 1000 liters per 100 km and fuel is cheap (and cars hold enough liters to drive around everyday), people will buy them, use them and rarely think about it. Just like they do it today with 6 liters per 100km cars and don't think about how the combustion engine system is inefficient in terms of pure energy output. A lot of that energy goes into useless heat and noise. 6 liters of matter has the potential to fuel the planet for weeks if we were to extract it efficiently.

It doesn't matter if something is efficient or optimal when it comes to general consumer market. And, whether you like it or not, technology and software is now in the general consumer market, in the same area with clothing, cars and such.

Have you been noticing how annoying the clothing industry is? Home items? Furniture? I've never seen a laundry detergent or a hand cream bottle that wasn't downright obnoxious. I've used a potato chips package that was /easy to use/. It's everywhere: unusable, badly designed, over bloated with unnecessary solutions and optimized for marketing and fast development, not for good use. The things you're describing are not specific to software, it's about design in general.

The only places where things are truly not too damn awful are some parts of military and super high level industrial solutions, where stakes are wa-a-a-a-y higher and general consumer is a non-existent agent altogether.

>Yet half of webpages struggle to maintain smooth 60fps scroll on the latest top-of-the-line MacBook Pro.

You care, I care, but most people don't. Not because they're stupid, they just don't notice these things. And we can dream all day long that engineers finally wake up and realize the scale of the crap-monster we've been building for years, but I don't think any significant change will happen until the general population starts to care.

I've seen this just a few weeks ago: a professional marketing specialist is using a high end laptop with some bloatware in the browser. Forget 60fps, his pages were doing 10-12 fps at best, /and/ every time he moved the cursor to close a tab, an antivirus popup appeared on top of the button. He says "damn!", moves the cursor away, then slowly moves it back again from a specific angle, carefully trying not to invoke that popup. He succeeds and carries on with his task. I asked him, it's been months like that. Hundreds of times. Every day. He just doesn't know better, this is /what computers are/.

When a car makes barely works, we think it needs to be fixed asap. When a computer barely works, we think "those damn computers!".

The things that contributed to your depression are often minor annoyances to the people. Sorry. This whole statement is a good catalyst for a whole another mental issue, fuck.

This is why I stopped pleading to the developers and started pleading to the users. I want users to demand more and be angrier with the promise of computing.

But this is a wrong battle anyway, I think. You, me and our peers are in the 0.1% of the world population when it comes to opportunity, wealth and availability of technology. We care about browsers' fps because we don't think about whether or not our children will eat tomorrow. Not to dwell on the "first world problems", this is how global economy works.

Today when we say "the population is growing" and "the internet is growing", we actually mean "China, Asia and Africa are growing and connecting to the global economy and the internet". Software industry is as global as globalization goes, and, like any other industry, it often adapts to the lowest denominator with the best margins.

Millions of people move from powerty to middle class, and they are "the big wave" of new users for technology. If your father died of hunger, but you suddenly found yourself having a job and buying a smartphone, I bet it'll be a long time until you start caring about Android core size and Chrome's render speed. Even if you know a thing or two about technology.

What I'm trying to say is:

1. Most users in the developed countries are used to bad software.
2. Most users in the developing countries are conditioned to bad software from the beginning.

This is weird! An average Western European family has very different notions of "enough food" and "a good job" and "nice life" to an average rural family from a developing country. But when it comes to, say, Android apps, both families have pretty similar experience and expectations, I guess.

Insert equality rhetoric.

Why software 20-40 years ago was actually faster, more stable and nicer to use (as long as you invest some time to RTFM)? Because it wasn't built for the general public **and** wasn't built by the general public, it was very limited in both audience and developers.

Today there is no good incentive to make good software unless it's some highly specific professional product.

One can easily interpret this in a wrong way, I believe. Software becoming a mass product is ultimately good, but comes with some harsh transition periods.

>Google Inbox, a web app written by Google, running in Chrome browser also by Google, takes 13 seconds to open moderately-sized emails.

Well, Google inbox is discontinued next Spring, so, that's not a problem anymore. Especially for Google.

But, here comes my second point: even if you care about this stuff, you still use it, and as far as Google is concerned, that's a success. I asked you recently why did you switch away from Firefox back to Chrome, even though so many Google's design decisions are appalling for you and me. And I knew the answer: we don't have much choice. There are just a handful of alternatives, and everything is bad.

Individual developers at Google will probably agree with you, they probably care a lot about all that stuff. But Google-the-company is not the collection of those developers, it's another organism altogether. That organism, just like any other evolutionary being in a competitive global economy, tries to do the least to get the most. It's a corporation, it wants to make... no, scratch that, it wants to _have_ money, but not necessarily _make_ it.

>Windows 10 takes 30 minutes to update. What could it possibly be doing for that long?

Yeah, so? Is Microsoft having any difficulties because of that? Maybe, but I don't think they believe that. What can you do? Switch to Linux, ha?

Yeah, if that update takes 24 hours, I bet not much changes, people will still use it, because for the majority of people Windows = Computers. It's not "windows is slow", it's "this is what computers are".

And organizations will develop special routines and systems to deal with that "intrinsic nature of computation": have "windows update" weeks. As long as everybody in the world suffers, there is no competitive advantage of having faster updates. Or better software.

>Android system with no apps takes almost 6 Gb. Just think for a second how obscenely HUGE that number is.

Look at plastic and garbage in general. The amount of packaging is staggering, but only a handful of activists care. It's hidden and doesn't really affect us. Yeah, you need larger garbage bins, whatever. Just buy them.

Just like you need a larger SD card or a new phone. Just buy them.

---

My third point is that software industry consists of amateurs, mostly (see https://rakhim.org/2018/07/software-shouldnt-fail/).

/"The Web was the first global technological phenomena that was built and maintained by the amateurs. Computer hardware, software, and the internet itself were built by mathematicians and engineers. The Web was built by people like me."/

And that middle class thing comes into play again. Being an amateur web developer is a way to bring your family out of poverty for many people. See success stories of many boot camps and such. If I couldn't provide for my family, but then I learned how to combine 10000 node modules into an electron app, and some company pays me money for that, I will happily make a lot of electron apps long before I start worrying about problems that most of the users don't have.

Bad sofware design and bad UX are ethically acceptable.

The machine is self-supporting and recursive: the more amateurs build software, the more developers we need to support it, thus creating more demand for new people becoming developers ASAP. More amateurs building software creates more amateurs building software.

Keep in mind that this is a net positive result for the individual lives of people and communities in the short term, even though it /might/ be a net negative for the civilization at large. Considering this, talking about this is very difficult.

>A 3D game can fill whole screen with hundreds of thousands (!!!) of polygons in the same 16ms and also process input, recalculate the world and dynamically load/unload resources. How come?

Several things:

1. Gamers *care*. See millions of views and comments to videos about minor differences in gaming performance.
2. A game costs 60€. People can return games if they're slow or bad (because they care). An iPhone/Android app costs cents. You can't return them. Free apps cost nothing and have miniscule margins of profit for devs (ads).
3. Slow games are actully unusable. You can't play at 15fps, it's just physically uncomfortable. But reading web at 10fps is, well, like Kindle. It's fine.

Another big idea about games I wanted to refer to is console games. This is the industry we can learn a lot from! Unlike PC games, console games seem to be much more stable. Because when Sony unveils a new PS, it says "this thing is THE console for the next 8 years. Have fun!"

Game devs know the schedule, and can take their time to tailor code to that particular, immutable and stable system. This is why every year new console games look better and better, even though the underlying hardware doesn't change at all. Devs squeeze the shit out of the resources.

Compare first PS3 games and last PS3 games. It's crazy. Same hardware!

Web developers don't care that much, next year their product will probably work faster (given it doesn't break due to browser update or API deprecation), because next year the average smartphone CPU will be faster.

>A simple text chat is notorious for its load speed and memory consumption. Yes, you really have to count Slack in as a resource-heavy application. I mean, chatroom and barebones text editor, those are supposed to be two of the less demanding apps in the whole world. Welcome to 2018.

Notice how the biggest and probably one of the most complex software projects in the history is being developed without Slack. Those Linux kernel devs, how can they work like that?! Without real time chat! Without Slack integration with CI and github?! Without notifications?! They still communicate via email, those weirdos!!!

I often hear this: "Slack is great because of integrations, we see errors and status updates and CI live in our chat!".

When the whole world is updating like crazy because everyone else is doing this, not necessarily because it's intrinsically good for the users, and the teams have to grow big to cope with the speed, and the technology has to be fragile and complex because Lean and Agile... you have no choice but to monitor and react to the system updates like a team of military doctors.

This doesn't make Slack an intrinsically good product. But it's **necessery** given the state of things.

*"This complex portable surgeon robot is great, it allows us to move fast every time we shoot ourselves in the foot!"*

So, you can't make truly good apps because you're a team of amateurs in the world full of similar competition, and to be able to move you NEED slack. If slack is 2x slower tomorrow, you take it, you NEED it.

>Nobody understands anything at this point. Neither they want to. We just throw barely baked shit out there, hope for the best and call it “startup wisdom”.

Yup. 100% this.

It seems, individual users don't matter anymore. As long as the final majority of users end up in the "okay, I guess it works" state, we're golden.

I'm all for your "Better world manifesto", sign me up. But I think that developers are not the bottleneck, the users are. We do have the responsibility, but this is an industry change we're talking about, and only markets seem to be able to effectively change industries.

Until we all live in some perfect society, there will be huge markets full of users with "other problems than your stupid app". And as long as it makes economical sense to produce cheap crap, it will be produced.
** DONE Dumb Down the Context Until the Problem Goes Away :good:
CLOSED: [2018-09-14 Fri 21:10]
:PROPERTIES:
:EXPORT_FILE_NAME: dumb-down-the-context-until-the-problem-goes-away
:END:

At work we use SCSS and HAML, so I rarely write pure HTML and CSS there. But for small side projects and my personal blog I tend to stick with the simplest (and dumbest) possible tools. This week I was working on a refreshed look for this blog. Being a good modern man, I tried to stick with =em= or =rem= for sizing and typography.

Using =em= means adding state to your specs, and I don't like this. Looking at a particular element, it can be impossible to understand what =em= means. So =rem= it is.

The value =rem= is "equal to the computed value of font-size on the root element", so starting with this:

#+BEGIN_SRC
html {
  font-size: 21px;
}
#+END_SRC

we suppose to get a universal and stable variable. =10rem= now means =210px=. Cool? Not so much.

I wrote a simple media query to make headers smaller on narrow screens:

#+BEGIN_SRC
@media (max-width: 34rem) {
  h1 {
    font-size: 2.369rem;
  }
}
#+END_SRC

But it doesn't work at the specified break point of =34rem = 714px=. Turns out that in media queries =rem= means "initial value of font-size", as per spec[fn:1]. It's =16px= in most browsers.

You have two lines of code near one another, and the same symbol means different things. Check out this [[https://fvsch.com/browser-bugs/rem-mediaquery/][demonstration]]. And you dare to complain about mutations in your imperative programming language!

[[https://adamwathan.me/dont-use-em-for-media-queries/][Using =em='s in media queries brings problems]] as well. So, in the end, pixels are the only units that behave consistently across all browsers and don't add hidden qualities to your styles.

I then thought okay, I can get around this problem by using =calc=, which seems to be supported in all browsers nowadays.  Nope, it doesn't work in media queries.

The first thought that came after that is almost a reflex for many web developers alike: just use some tools on top of this ugly and inconsistent language!

A pre-compiler like SCSS provides variables and calculations and other sweet features. It can seamlessly generate final CSS if you enable a watcher, or even better, set up something like Gulp or Webpack (oh, god). But then it'll be kind of difficult to use the web inspector in the browser, since it shows the final CSS, but I never work with it directly.

Oh, no worries, you can generate source maps for SASS/SCSS. Magic[fn:2]!

But wait... While this solves my problem, it adds a tremendous amount of complexity. Is it worth it? Clearly, not in my case, but for a huges project like Hexlet at my main job it clearly does. Where is the threshold? How does one know when it's worth to invest into a set of new abstractions that comes with their own quirks and problems?

It's a difficult question, but for me and my small projects I found it important to remind myself: resist complexity at all costs, resist adding new things into the system. If my problem asks for a solution that involves additional tools or systems, first and foremost consider dumbing the whole thing down so that the problem goes away. By regressing to pixels, which are so "not modern", I managed to avoid a whole bag of cruft being put on top of this primitive project. The system became dumber. It's a win for me.

This is a weak example, I agree, so let me provide another one. Few years ago I needed to launch a small wiki site. Many popular wiki engines (like MediaWiki) are way too complex and feature-rich, so I looked for simpler alternatives. I found a nice Ruby library[fn:3] and spend few hours setting it up, providing custom templates and styles. I was happy with the result, but then I found myself daunted by the worst part: deploy and maintenance.

Of course, setting up a server by hand is a no-no, so I had to write an Ansible recipe for Ubuntu Rails environment. Accidental complexity involved in this problem became so large I started forgetting what I was trying to achieve.

It took me some time to realize that the primary audience for this wiki will actually be much more comfortable editing text directly via Git rather than fiddle with a web interface. And if it's hosted on GitHub, I don't have to worry about authorization and accounts. I still needed it to run on my domain with some specific HTML, so I just made a simple Jekyll site and provided links to quickly edit and send pull requests via GitHub.

I had problems associated with deployment and maintenance, and instead of adding tools as solutions, I dumbed the whole context so that the problems went away.

Note that these problems are often of accidental complexity type. Intrinsic, real problems don't surrender this easily.

If playing with lots of inter operating tools is fun, by all means go for it. As long as you /remember/ and /realize/ what is going on. Complexity is not inherently bad, it's just sort of cunning when you're not mindful.

[fn:1] https://www.w3.org/TR/css3-mediaqueries/
[fn:2] https://robots.thoughtbot.com/sass-source-maps-chrome-magic
[fn:3] https://github.com/goll
** DONE Keyboard fanaticism :good:
CLOSED: [2018-09-10 Mon 16:54]
:PROPERTIES:
:EXPORT_FILE_NAME: keyboard-fanaticism
:END:

I've been reading [[https://sites.google.com/site/steveyegge2/effective-emacs][an article about Emacs]], and this paragraph had nailed me right into the soul:

#+BEGIN_QUOTE
IDE users spend most of their time fumbling around with the mouse. They wouldn't dream of doing it any other way, but they don't realize how inefficient their motions are.

...

Whenever you need to jump the cursor backward or forward more than about 5 lines, and you can see the target location, you should be using i-search.
...

Let your eye defocus slightly and take in the whole paragraph or region around the target point, and choose a word that looks reasonably unique or easy to type. Then i-search for it to navigate to it. You may need to hit Ctrl-r or Ctrl-s repeatedly if your anchor word turns out not to be unique.
#+END_QUOTE

This is a common rhetoric: use keyboard only, don't you dare to use the mouse — it's so inefficient!

The scenario in question is simple: you have to move the cursor to some position you see on the screen. Instead of moving your hand to the mouse to move the pointer, the author suggests the following algorithm:

1. Determine if the place you need to go to is before or after current position. This is non-zero mental work.
2. Take a look around that point and "choose a word that looks reasonably unique". Perform more mental work of determining which word is unique enough.
3. If the target is before the current position, use =Ctrl+s=. If it's after, use =Ctrl+r=. This is more or less automatic, but still required mental work of maintaining the mapping between direction and binding.
4. If your judgement of the uniqueness wasn't good enough, you'll end up somewhere else. Possibly, in a completely different section of the document. Additional mental work — you have to realize what happened, disoriented. Keep hitting =Ctrl+s= or =Ctrl+r=. And you have to keep scanning the surroundings every time you jump until you get where you want.
5. Okay, you're there! But remember, you've been jumping to a place *near* the target, so now you have to move a bit more — by word or by character.

#+BEGIN_QUOTE
Mastering it simply requires that you do it repeatedly until your fingers do it "automatically". Emacs eventually becomes like an extension of your body, and you'll be performing hundreds of different keystrokes and mini-techniques like this one without thinking about them.
#+END_QUOTE

While I understand the premise completely, and I occasionally use the same technique, I can’t help but think an advice like that rarely takes into account the trade-off. Yes, moving your hand to the mouse takes time, but it’s not uncommon that the time required is actually *less* than multi key multi step keybinding. Instead of spending a second, two motions and a single click the user is advised to analyze text, make several decisions and hit multiple keys, which might or might not be enough. But hey, you didn't leave the home row, so, win, I guess?..

I'm not defending the mouse here, but I do think there are occasions where using the mouse is just better *for me*. Too often these articles are trying to make you feel like an unintelligent cave man for daring to use the "device of IDE users".

Also, Emacs packages like [[https://github.com/abo-abo/avy][avy]] or [[https://github.com/hlissner/evil-snipe][evil-snipe]] make jumping to visible text much simpler and cost less mentally.

The vast sea of discussions and advice about programming tools and especially text editing is full of opinions, approaches and cult-like repeated revelations. Often, the loud sounds of the echo chamber make it difficult to stop for a moment and evaluate something yourself. But please do try.

It's easy to be indoctrinated.
** DONE Personal finances and controlled anarchy :good:
CLOSED: [2018-09-07 Fri 12:31]
:PROPERTIES:
:EXPORT_FILE_NAME: personal-finances-and-controlled-anarchy
:END:

Most of my life, I didn't have much money. I was born in the 90s in a tiny Kazakh town, and nobody had a job there, it seemed. USSR just collapsed and my parents were trying to make ends meet in a constant hustle.

That life defined my relationship with money and wealth for years to come. Every time I had to buy coffee, I was thinking "is it worth it?.. Maybe I shouldn't". In restaurants and cafes I was looking at prices first, then at meals. "Hmm, this cheap pasta looks so attractive! Ooh, I bet this expensive steak is not that good".

"You know what? I'll just buy this coffee and not buy that iPhone game I wanted to buy. Yeah, perfect! Now I'm calm and safe!"

After graduating and starting working full time I decided to follow a popular advice: budget everything. I started using an excellent app called [YNAB](https://www.youneedabudget.com/) — You Need a Budget. Not only it allows you to track all your expenses and plan ahead, it also comes with a philosophy, a set of rules and ideas to help you navigate your personal finance world.

First things first: save one month worth of expenses and never let your account get dry. The idea is to be spending money that is at least 30 days old. So, if you got your salary on February 1st, you will spend this money in March or later, but not in February. This way you never get into «I need some money until my next salary».

Next, give every dollar a job. This means that each dollar you get — you decide what it's for. I have regular expenses like rent, phone fees, groceries etc. Some amount of money MUST go there. But I also have other categories, like "Books" or "Electronics" or "Travel". And if I want to buy a book or go for a vacation, I have to have enough money saved in that category.

Putting money into savings account is another type of a job.

YNAB allows you to assign every dollar a particular job. It actually encourages you to keep exactly ZERO cents unassigned! You feel like a finance director of a small enterprise. Serious business!

This way you know exactly whether you can afford something. And you never have to guess "hmm, if I buy this laptop now, will I be okay with the rent?..".

*[[/images/posts/ynab.jpg]]*
/YNAB classic app screenshot (not mine)/

Another YNAB rule is to budget in detail and ahead. "Make your money boring" is their slogan for it. For every bill to come or an unexpected expense to surprise you, you'll have money waiting.

For example, I was putting some money into "Car repair" category each month, even though for the most part my car didn't require any repair. But when the AC compressor suddenly died in the middle of the hot German summer vacation, I knew I don't have to worry.

Basically, save money for Christmas all year long, not just in December.

One more YNAB rule is to "Roll With The Punches". When you overspend in a budget category, just adjust. No guilt necessary! It was easy for me to justify another gadget when I under-spent in some other categories.

I was an everyday user of YNAB for 7 years. The app itself is 14 years old and it has a great following and a nice community around it. It helped me *tremendously*! A huge amount of stress just went away, I was on top of my finances, I knew exactly what's happening and how much money I'm getting and spending. When my girlfriend moved in with me and we started sharing our budgets, YNAB was able to accommodate it. I just added another bank account in the settings. In total, I was controlling multiple bank accounts (including "cash" account) and cards, several sources of income and tens of budgeting categories.

It was great.

So, why did I stop?

Don't get me wrong: an app and a method like that makes a HUGE difference. I will never go back to having no control and no knowledge over my finances, but I still had lots of stress points.

First, it took a lot of time and energy to maintain the system. I had to put all the expenses precisely, every purchase, every fee, including cash purchases. The system makes sense only if you're precise and 100% accurate.

Card purchases overseas were especially painful. They often change over time, like, you buy something off Amazon, and they charge you with currency conversion, and after a week or so an "adjustment" charge is made silently (since the exchange rate changed a bit). You have to track it all and "consolidate" your accounts every month.

Or you just forget what that $0.99 supermarket purchase was three weeks ago. Was it chocolate, so, groceries category? Or a LAN cable, so, electronics category? Does it really matter? It's just 99 cents, so… whatever, let it be groceries.

Another problem was — I still had some stress over money. Less than before, but still. This "roll with the punches" rule is nice and liberating, but sometimes it seemed like I was just abusing the system. I want a new gadget, so, I'll just transfer $100 from "car repair" and compensate next month by spending less in every category. It'll be just fine!

It takes lots of energy not only to maintain the system, but to keep disciplined. I'm not that good at it.

A year ago I decided to deliberately simplify my life. Automate everything I can, ignore more stuff, eliminate pain points and minimize the mental energy requirements on everything except first-order things.

First-order things are the actual things I want to spend time on, the things that are intrinsically important for me. Money is a tool, so, it's at most second-order. It allows for the first-order things, but it doesn't have intrinsic value itself.

So I ditched YNAB and budgeting in general.

This was the most liberating moment I had in some time!

I call my new system "controlled anarchy", and it's pretty simple.

Every time our family gets salary payment or other income, I distribute it between three bank accounts:

1. *Monthly bills.* This account pays all the bills, from rent to Netflix. It has its own debit card, so I don't really see the purchases very often. I know exactly how much money is spent, though, since all the expenses here are static. Like with YNAB philosophy, this account has 2 months of expenses all the time, so it never gets dry. (I am actually increasing this account to 6 months of expenses so it will act as the emergency fund. Bad things happen — we have 6 months to figure things out).
2. *Savings.*. Yup, just savings. At least 33% of all the income is saved. A portion of it is invested in mutual funds for the long term.
3. *Everyday spending.* The rest is free! This is the key — I don't have to plan or to calculate or track anything. This account is the free money we can spend however we want! (Some of it goes to groceries, but the rest is truly free).

The Everyday spending account rarely gets to zero, and we never move money away from it. So, it actually grows gradually, and if we don't spend it all one month, we get even more free money next month!

The goal is to eliminate guilt and uncertainty about purchases. You want that new thing? Just buy it if there's enough money. Not enough in Everyday spending? Well, sorry, you can't buy it. But hey — feel free to buy whatever — spend it all away!

Oh, man, this made our lives so much easier.

The "controlled anarchy" system lacks the precision of the previous one, but requires no time and energy to maintain. All the payments and transfers are automatic, it's like we're kids and a wise parent manages our spending money :)

This is what I call simplification: less decision-making means more energy for the truly important things.

Now, if you don't do any sort of budgeting and don't really control your money, I'm not sure going into "controlled anarchy" right away is a good idea. It seems like it's alright, but maybe you should try real detailed budgeting first, maybe for a year or so, just so that you understand what's going on, where money goes to.
** DONE Dazed, depressed, defunct :good:
CLOSED: [2018-10-31 Wed 14:52]
:PROPERTIES:
:EXPORT_FILE_NAME: dazed-depressed-defunct
:END:

I've been journaling daily for 6+ years, but stopped this summer. There are many reasons, but one stands out: it makes me sad to read my journal.

DayOne app has a nice feature: show entries for "this day over the past years". I used to start each morning by reading 5-6 journal entries from the previous years. This routine has been more or less automatic, and it didn't feel like it was in any way affecting me. It took me an unreasonable amount of time to realize how disturbingly repetitive my journal entries are. Most of the time I was "temporarily sad" or "feeling depressed" or "tired and frustrated, whatever".

It goes on and on...

*[[/images/posts/journal.png]]*

*** Getting lonely

I felt lonely most of my life. I can't say I had ever had long, true friendships or partners. I remember tolerating most of the circumstances and people, at best. But, being a young university student around 10 years ago, it wasn't an issue: there were too many things to worry about, and there were ways to relax and dumb down the brain, if you know what I mean. The body can really take a beating so that the mind is spared.

Closer to graduation, I found myself frustrated with everyone and everything around me. I deliberately made myself completely alone and isolated, in a foreign country, working in a different town, so that I can "leave" multiple times a day: leave home, leave the town to commute, then leave the office, leave the group. I didn't talk to anyone except colleagues during weekdays and the person who became my girlfriend and life partner several years down the road. She eventually became the only person I could discuss these issues with.

For almost 8 months I had a bizarre groundhog day experience every day. It didn't do good.

In 2012 I left the country, changed jobs, got back into public speaking, finally met that girl. It felt like things are changing for the better.

Turned out, those external events had nothing to do with the way I felt inside. It's hard to fathom: even a 100% change in circumstances and environment could theoretically contribute exactly 0% to the internal feeling.

I didn't take notice and kept chasing. Another city, another job, another side project. 10 months in --- no, back to the other city, another job. No, working for the man is not for me, I want my own business. Attempt one, attempt two, attempt three... I have no idea what I'm doing. I know! Startup! Investors! Rounds! Yes, this is what I was missing!

I went all in. Quit my job, started learning about startups, lean and customer development. Pitching like crazy, applying to bootcamps and "accelerators". Dreaming of Round C. It was an efficient, but costly life-filler.

As you can imagine, that didn't do good either.

*** Getting frustrated

Co-founding a startup when you're not right mentally and when you have no idea /what you want/ is a bad, bad idea. Almost hitting rock bottom money-wise, risking the livelihoods of multiple people and your own legal status in a country you're trying to make your home is a fucking shit show of emotions and, surprisingly, numbness.

I guess, statistically I was numb most of the time, not frustrated or tired or depressed. Just numb, slowly moving towards that dark and moist sweet spot of groundhog-day-like existence. Daily routines became the refuge. Weekends became wanted again, not because I could relax, but because I could ignore.

I remember washing dishes being the best thing to do some days. Yeah, washing dishes for an hour, slowly going through a pile, seeing definite progress, having my hands in nice, warm water, having a feeling of accomplishment in the end.

Surprise! Investors don't really like it when you're stalling. Or have no plans for the next quarter. Surprise! You're not CEO material. Not leader material, really. Surprise! You still have no idea what you want.

Self-hatred-driven personal development is a promising area of self-help literature, I think.

Surprise! You suck! Go, write that in your dreary sobbing journal.

*** Getting defunct

While external positive circumstances don't really change much, external /negative/ circumstances do work as advertised. Feeling depressed? How about feeling depressed and broken? There you go!

As an example of things piling up on top of all this: the government retroactively stripped me of the scholarship they awarded me with 12 years ago for "violating" a condition that is not in my contract, but exists in their internal documents which they failed to provide after numerous requests. Seven years after graduation, I was handed a large, unexpected student debt. Suing the government doesn't really work there, so, yeah...

Or a business partner threatening us (co-founders) with "legal action" for not taking the canonical growth startup path, but rather deliberately deciding to stay small-ish.

After multiple roller coasters, after months of not being able to do any meaningful work, after a personal trip that didn't go well, I found myself broken. I didn't have suicidal thoughts, don't worry, but I remember feeling that it doesn't matter if I die. I mean, I don't /want/ to, and it won't be good for my partner and parents, but, you know... it's not... yeah. It's just "whatever".

It made me shiver when my mother, whom I see about once a year since I left home at 18, told me "your eyes seem faded". Before that I used to think I'm pretty good at hiding this shit inside.

Last week I decided to step down as CEO of Hexlet, the company I co-founded in 2015 with Kirill Mokevnin. I started it as a hobby project in 2008 and it grew to a profitable educational business with 200 000 users and 7 employees. It has *great* potential, but it needs a real leader.

*** What now?

I don't know.

I guess, first things first, I need to fix myself at least to the point of making money to pay off the unexpected debt. I know /intellectually/ this is possible. And maybe this is the kick in the butt that'll do good. Or not.

Sometimes I am able to force myself to work creatively and produce something like an article for this blog or a video for my channel or a podcast. The moment of publishing and getting any sort of feedback brings a fleeting feeling of hope, but inevitably leads to a period of numb emptiness, followed by self-deprecation for feeling that way. Sustainable creative work is the hardest thing to achieve.

There are things that definitely contribute positively: I started working out and taking care of sleep, I'm trying to cut on bad food and understand nutrition better. Again, intellectually it all makes sense, but for now, I am as lost as ever, dazed and uncertain.

I don't know why I'm writing all this. It promised to be cathartic, but maybe I should stop listening to external promises...

[[/images/posts/dazed.png]]
** DONE A Simple Introduction to Proof by Induction :good:
CLOSED: [2018-09-20 Thu 17:18]
:PROPERTIES:
:EXPORT_FILE_NAME: a-simple-introduction-to-proof-by-induction
:END:

Now that you're familiar with [[/2018/09/a-simple-introduction-to-proof-by-contradiction/][direct proof and proof by contradiction]], it's time to discover a powerful technique of proof by induction.

/Aside: do not confuse mathematical induction with inductive or deductive reasoning. Despite the name, mathematical induction is actually a form of deductive reasoning./

Let's say, we want to prove that some statement $P$ is true for all positive integers. In other words:

$P(1)$ is true, $P(2)$ is true, $P(3)$ is true... etc.

We could try and prove each one directly or by contradiction, but the infinite number of positive integers makes this task rather grueling. Proof by induction is a sort of generalization that starts with the basis:

*Basis:* Prove that $P(1)$ is true.

Then makes one generic step that can be applied indefinitely:

*Induction step:* Prove that for all $n\geq1$, the following statement holds: If $P(n)$ is true, then $P(n+1)$ is also true.

See what we did there? We've devised another problem to solve, and it's seemingly the same. But if the basis is true, then proving this /inductive step/ will prove the theorem.

To do this, we chose an arbitrary $n\geq1$ and assume that $P(n)$ is true. This assumption is called the /inductive hypothesis/. The tricky part is this: we don't prove the hypothesis directly, but prove the $n+1$ version of it.

This is all rather amorphous, so let's prove a real theorem.

*Theorem 1.* For all positive integers $n$, the following is true:

\begin{equation}
\label{eq:1}
1 + 2 + 3 + ... + n = \frac{n(n+1)}{2}
\end{equation}

*Proof*. Start with the basis when $n$ is $1$. Just calculate it:

$$ 1 = \frac{1(1+1)}{2}. $$

This is correct, so, the basis is proven. Now, assume that the theorem is true for any $n\geq1$:

\begin{equation}
\label{eq:2}
1 + 2 + 3 + ... + n = \frac{n(n+1)}{2}
\end{equation}

In the induction step we have to prove that it's true for $n+1$:

\begin{equation}
\label{eq:3}
1 + 2 + 3 + ... + (n+1) = \frac{(n+1)(n+2)}{2}
\end{equation}


Having this equation, we should just try to expand it and prove directly. Since the last member on the left side is $n+1$, the second last must be $n$, so:

$$ 1 + 2 + 3 + ... + (n + 1) = 1 + 2 + 3 + ... + n + (n+1) $$

From our assumption, we know, that

$$ 1 + 2 + 3 + ... + n = \frac{n(n+1)}{2}. $$

So, let's replace it on the right hand side:

$$ 1 + 2 + 3 + ... + (n + 1) = \frac{n(n+1)}{2} + (n+1) $$

And then make that addition so that the right hand side is a single fraction:

$$ 1 + 2 + 3 + ... + (n + 1) = \frac{n(n+1)}{2} + \frac{2(n+1)}{2} $$

$$ = \frac{n(n+1) + 2(n+1)}{2} $$

$$ = \frac{(n+1)(n+2)}{2}. $$

Done, we have proven that the inductive step (\ref{eq:3}) is true.

There are two results:

1. The theorem is true for $n=1$.
2. If the theorem is true for any $n$, then it's also true for $n+1$.

Combining these two results we can conclude that the theorem is true for all positive integers $n$.

-----

I had troubles with this technique because for a long time I couldn't for the life of me understand why is this /enough/ and how is the basis /helping/?! The basis seemed redundant. We assume $P(n)$ is true, then prove that $P(n+1)$ is true given that $P(n)$ is true, but so what? We didn't prove the thing we assumed!

It clicked after I understood that we don't have to prove $P(n)$, we just take the concrete value from the basis and use it as $n$. Since we have a proof of $P(n+1)$ being true *if* $P(n)$ is true, we conclude that if $P(1)$ is true, then $P(1+1)$ is true.

Well, if $P(1+1)$ is true, then, using the same idea, $P(1+1+1)$ is true, and so forth.

The basis was the cheat-code to kick-start the process by avoiding the need to prove the assumption \ref{eq:2}.
** DONE A Simple Introduction to Proof by Contradiction :good:
CLOSED: [2018-09-12 Wed 17:49]
:PROPERTIES:
:EXPORT_FILE_NAME: a-simple-introduction-to-proof-by-contradiction
:END:

In mathematics, a theorem is a true statement, but the mathematician is expected to be able to prove it rather than take it on faith. The proof is a sequence of mathematical statements, a path from some basic truth to the desired outcome. An impeccable argument, if you will.

One of the basic techniques is proof by contradiction. Here is the idea:

1. Assume the statement is false.
2. Derive a contradiction, a paradox, something that doesn't make sense. This will mean that the statement cannot possibly be false, therefore it's true.

When I first saw this formal technique, it puzzled me. It didn't seem to be valid: alright, assuming something is false leads to a paradox, so what? We haven't proven that assuming it's true doesn't lead to another paradox! Or even the same paradox, for that matter. What I failed to understand conceptually is that a statement is a binary thing: it's either true or untrue. Nothing in between. So, if one can definitely declare "X is not false", then no other options are left: "X must be true".

*** Direct proof

To demonstrate this, let's first use another technique of a /direct proof/ so that we have something to work with.

*Theorem 1.* If \(n\) is an odd positive integer, then $n^2$ is odd.

A /direct proof/ just goes head in, trying to see what the statement means if we kinda play with it.

*Proof.* An odd positive integer can be written as \( n = 2k + 1 \), since something like \( 2k \) is even and adding 1 makes it definitely odd. We're interested in what odd squared looks like, so let's square this definition:

$$ n^2 = (2k + 1)^2 = $$
$$4k^2 + 4k + 1 = $$
$$ 2(2k^2 + 2k) + 1 $$

So, we have this final formula \( 2(2k^2 + 2k) + 1 \) and it follows the pattern of \( 2k + 1 \). This means it's odd! We have a proof. ■

This theorem is based on an idea that numbers described as \( 2k + 1 \) are definitely odd. This might be another theorem that requires another proof, and that proof might be based on some other theorems. The general idea of mathematics is that if you follow any theorem to the very beginning, you'll meet the fundamental axioms, the basis of everything.

Now that we have this proven theorem in our arsenal, let's take a look at another theorem and prove it by contradiction.

*** Proof by contradiction

*Theorem 2.* \(n\) is a positive integer. If \( n^2 \) is even, then $n$ is even.

We may try to construct another direct proof, but creating paradoxes is much more fun!

*Proof.* Let's assume that \(n^2\) is even, *but $n$ is odd*. This is the opposite of what we want, and we will show that this scenario is impossible.

$n$ is odd, and from Theorem 1 we know that $n^2$ must be odd. This doesn't make sense! Our assumption and our conclusion are the opposite. This is a paradox, so the assumption was wrong. Meaning, the idea "\(n^2\) is even, but $n$ is odd" is false. Therefore, the idea "\(n^2\) is even, $n$ is even" is true.■

*** Famous irrational \( \sqrt{2} \)

*Theorem 3.* \( \sqrt{2} \) is irrational.

Woah, this is... different. In the first two theorems we had formulas, something to play with, something physical. This now is just an idea, so how would we even start?

Let's start with a definition.

#+BEGIN_QUOTE
In mathematics, the irrational numbers are all the real numbers which are not rational numbers.[fn:1]
#+END_QUOTE

Doesn't seem helpful, but let's continue. What are rational numbers then? Are they some reasonable beings who make optimal decisions all the time?

#+BEGIN_QUOTE
A rational number is any number that can be expressed as the fraction \(\frac{p}{q}\) of two integers.[fn:2]
#+END_QUOTE

Oh! They are rational because they are /ratios/!

Just to make things super clear, let's dig one more step and make sure we understand integers.

#+BEGIN_QUOTE
An integer (from the Latin /integer/ meaning "whole") is a number that can be written without a fractional component. For example, 21, 4, 0, and −2048 are integers, while \(9.75\), \( 5\frac{1}{2} \) and \( \sqrt{2} \) are not.[fn:3]
#+END_QUOTE

Combining these things, we can construct a comprehensive definition of an irrational number: it's a number that cannot be expressed as the fraction of two whole numbers.

Now, let's apply this to Theorem 3 so that it has some meat:

*Theorem 3.* \( \sqrt{2} \) cannot be expressed as \( \frac{p}{q} \), where $p$ and $q$ are integers.

Alright, now there is something to play with!

*Proof.* Start by assuming the opposite -- \( \sqrt{2} \) is rational. This means it can be written as a fraction of two integers:

$$ \sqrt{2} = \frac{p}{q}\ $$

We can assume that $p$ and $q$ are not *both* even, because if they are, we can reduce them by dividing both by a common factor (like, for example, \( \frac{8}{10}\ \) should be reduced to \( \frac{4}{5}\ \)). In other words, if they are both even, reduce them until at least one is odd and no further reductions are possible.

Now, let's square the square root:

$$ (\sqrt{2})^2 = \frac{p^2}{q^2}\ $$

$$ 2 = \frac{p^2}{q^2}\ $$

$$ p^2 = 2q^2 $$

Remember, something like $2k + 1$ is odd, and $2k$ is even. Here we see this pattern: $p^2 = 2q^2$, which means that $p^2$ is even (it consists of /two/ things).

Then, using Theorem 2, we can say that $p$ is even as well, which means we can write $p$ as $p = 2k$. So:

$$ 2q^2 = p^2 = (2k)^2 $$

$$ 2q^2 = 4k^2 $$

Divide both by two:

$$ q^2 = 2k^2 $$

So, $q^2$ is even. By the same Theorem 2 it follows that $q$ is even.

Let's summarize the two conclusions:

1. $p$ is even.
2. $q$ is even.

Wait... We made sure that not both $p$ and $q$ are even before starting this whole thing! We made sure to reduce them until at least one is odd, but then, by applying Theorem 2, we ended up with two even numbers. This is impossible, so the idea that "$\sqrt{2}$ is rational" is not true.

Therefore, $\sqrt{2}$ is irrational.■

/P.S. I often use proof by contradiction in real life by arguing that, for example, not eating the whole bucket of ice cream at once will lead to a paradox that endangers the whole fabric of space-time. It works for me, but your mileage my vary./

[fn:1] https://en.wikipedia.org/wiki/Irrational_number
[fn:2] https://en.wikipedia.org/wiki/Rational_number
[fn:3] https://en.wikipedia.org/wiki/Integer
** DONE Moved from Jekyll to Hugo and ox-hugo
CLOSED: [2018-09-03 Mon 17:13]
:PROPERTIES:
:EXPORT_FILE_NAME: moved-from-jekyll-to-hugo-and-ox-hugo
:END:

I have changed the setup for this blog from Jekyll + Github to Hugo + ox-hugo + Netlify. The main goal was to be able to write blog posts from within Emacs and reduce as much traction as possible. Also, Org mode is much more comfortable to write in compared to any Markdown editor I've tried.

*** Previous setup

I've been using Jekyll and Github pages for a long time, and it was generally a good experience. I don't have big complaints about Jekyll. It can be a bit clunky when it comes to things like tags, but I don't use them anyway. My [[https://rakh.im/][Russian blog]] is still powered by it. One thing that is never fun — the need to manage Ruby environment and dependencies. Some people prefer to encapsulate everything into Docker containers, and I've tried that with Jekyll as well, but the overhead complexity is not worth it.

I was using Sublime Text or sometimes iA writer to write posts. The whole process was full of small steps that added friction. I fully acknowledge that this sounds like "the tools stopped me from being a prolific blogger, if only I had better tools" fallacy.

This is how it looked like for the most part:

1. Go to iTerm, navigate to my blog directory and start Jekyll server.
2. Open the project in Sublime.
3. Create a new Markdown file with a correct name (e.g. =2018-01-11-be_bored.md=). I have a bash script to quickly create a new file with some front-matter inserted by default.
4. Go to browser, reload page, open post.
5. Write Markdown in Sublime, reload page to see result.
6. Push to Github when ready.

Sometimes thing go bad and Github build fails. There is no clarification, and on rare occasions I had to contact support to find out the actual build error output. GitHub's support is excellent, but this process is no fun.

*** New setup

Now I use [[https://gohugo.io/][Hugo]] static site generator, but don't write Markdown myself. I write in Org mode (I talked about it in [[http://emacscast.rakhim.org/episode/754222a0-714c-41b6-9203-8d0dc0d6210f][EmacsCast episode 2]]) and use [[https://ox-hugo.scripter.co/][ox-hugo]] to generate Markdown files for Hugo to then generate static HTML. Yeah, seems like too many moving parts for the sake of the simplest page possible, but it works remarkably well and — worst case scenario — if Emacs or Org or ox-hugo go bad, I can go back to essentially the same process as before.

This is how it looks like:

1. Go to Emacs, open my blog project (one second worth of key strokes thanks to [[https://github.com/bbatsov/projectile][Projectile]] and [[https://github.com/emacs-helm/helm][Helm]], which were also mentioned in [[http://emacscast.rakhim.org/episode/754222a0-714c-41b6-9203-8d0dc0d6210f][EmacsCast episode 2]]).
2. Open shell buffer, start Hugo server, open browser.
3. Write new post. All posts are stored in a single Org file, so I don't need to create new files. The name of the final Markdown file is generated automatically from the post title.
4. Save Org file. New post is generated and browser is redirected or refreshed.
5. When ready, change the Org status of the section to *DONE*.
6. Use Magit or a single Bash script to add, commit and push files to Github.
7. Netlify picks up the commit and builds the pages. If something goes wrong, I can see the detailed build logs.

*[[/images/posts/oxhugo.png]]*

And with Org capture I can create a new draft from anywhere in Emacs with two key strokes.

*** Nice things about Hugo

There are several small things that make Hugo nicer than Jekyll for me:

1. With =hugo server -D --navigateToChanged= the browser navigates to the changed file automatically and refreshes the page on each change. No need to refresh the page manually! Instant Markdown preview.
2. Hugo is distributed via Homebrew, and I don't need to care about Ruby environment and dependencies like I had to with Jekyll.
3. I have several sites, and Hugo randomizes the port if the default port is in use. A tiny nice detail.
4. It seems much faster than Jekyll.

*** Nice things about Org and ox-hugo

While this transition was mainly performed due to workcrastination, I'm pretty happy with the results. Hugo itself wouldn't be the reason to switch, it's the combination of Org + ox-hugo + hugo that makes it all worth the hassle.

Writing in Org is arguably a more pleasant experience compared to Markdown. Being able to integrate blogging into the same program that is used for planning, programming and long-form writing is very nice.

The whole blog setup, including this custom theme is available on [[https://github.com/freetonik/rakhim.org][Github]].
** DONE Office hours
CLOSED: [2019-05-21 Tue 12:45]
:PROPERTIES:
:EXPORT_FILE_NAME: office-hours
:END:

As an experiment, I am holding paid office hours for several weeks. I'd love to share whatever limited experience I've gained so far. You can schedule a 30 or 60 minute audio call to talk (in English or Russian) about any of the following topics:

1. *Computer science and programming*.
   - Discuss a fascinating idea.
   - Feeling lost and want to understand something.
   - No code review or debugging. Consider hiring a private mentor (on sites like codementor.io) for that.

2. *Software development career*. I have experience being hired and hiring developers, being managed and managing teams, working on client projects, freelancing and on my own private businesses.
   - How to chose what to learn and where to work.
   - Freelancing vs. full time work.
   - How to grow professionally.
   - How to get promoted.

3. *Professional immigration*. I've been through several work-, education- and entrepreneurship-based immigration processes in Canada (Federal and Quebec) and Finland.
   - How to chose a country that suits you and your family.
   - North America vs. Europe
   - English exams
   - Preparation, process, first steps after landing.

4. *Entrepreneurship and startups*.
   - Starting your own business.
   - Raising funds.
   - Growth, goals and metrics.

5. *Education and/or immigration*.
   - Learning English.
   - What to study in college.
   - How to study abroad. Scholarships, immigration, work after graduation.

6. *Self management*.
   - Getting things done
   - Focusing on hard tasks
   - Managing distractions
   - Reducing mindless browsing, social media influence, digital addictions

7. Other:
   - simplifying life
   - digital essentialism
   - managing complexity in life
   - public speaking
   - podcasting
   - blogging
   - ... and almost anything else :)

Book your meeting at [[https://calendly.com/rakhim][calendly.com/rakhim]]. Payment is processed there, along with the booking. Email me at [[mailto:contact@rakhim.org][contact@rakhim.org]] if you have any questions.

UPD (2.7.2019): the office hours experiments is concluded. Thank you!

**** Testimonials

/I had a chat with Rakhim about education and mindfulness. His broad vision and aspiration to immerse in the asked questions helped me validate my current knowledge and gave me the direction for further growth. I recommend office hours if you feel kind of lost in a topic and want to know where to move on./ — *Andrew R*.

/One hour Q&A session had helped me to better determine my career goals and new ways to fulfill my interests in different areas of software engineering. Thanks to Rakhim, I've found new opportunities and ideas on how to improve my computer science knowledge, English, and other things. Thank you bro!/ — *Rustem Z.*

/Me and Rakhim were talking about doing business in Finland. We had just 30 minutes, but we managed to discuss visa, tax and legal aspects of working in Finland. Rakhim also sent me a bunch of useful links after the chat. It was a nice experience overall, can totally recommend./ — *Dmitry N.*
** DONE I no longer care about og tags, twitter cards, etc.
CLOSED: [2018-09-04 Tue 15:44]
:PROPERTIES:
:EXPORT_FILE_NAME: i-no-longer-care-about-og-tags-twitter-cards-etc
:END:

Enough.

Facebook, Twitter and other social networks have their own markup formats that "enable any web page to become a rich object in a social graph". For the most part it means that if you want to make your link look nice when people share it, you have to set some meta tags.

#+BEGIN_SRC html
<meta property="og:title" content="The Wonderful" />
<meta property="og:type" content="article" />
<meta property="og:image" content="/images/cover.jpg" />
#+END_SRC

This is a noble idea in the abstract, and one more attempt at creating semantic web, since you can not only specify titles and cover images for shared links, but detailed meta information as well, like the type of content, authors, dates, etc. Facebook is a for-profit company that just made all the decisions and created their own protocol. It's not open - there is no way for the public to participate in its development, unlike W3C's work. The only reason people are using this protocol is because often their livelihood depends on the amount of traffic that comes from Facebook. Of course they'd like to make their links look good in Facebook posts!

Some other social media sites support og tags with certain quirks. Like, you provide a cover image, but different sites crop them differently because they want consistent media proportions on their side. So, now your content looks link still looks like garbage and #webdesign Medium blog posts are full of "how to make your link look awesome in LinkedIn in 2018" tutorials.

The sheer amount of resources the industry pours into made up problems like that...

I decided not to care about this for my personal projects anymore. If someone wouldn't click on a link to my site because the link looks less attractive than a flashy colorful image, so be it.
** DONE Fast automatic remote file sync
CLOSED: [2018-10-17 Wed 11:11]
:PROPERTIES:
:EXPORT_FILE_NAME: fast-automatic-remote-file-sync
:END:

Our dev machines at Hexlet are remote, since the project is too big and resource-heavy for laptops. This good decision made by our CTO also means that the dev environment is freed from additional layers of complexity like managing Vagrant and Vbox.

Most of the devs work directly on the remote machines using vim. I used Sublime before Emacs, and seamlessly synced all changes using an excellent [[https://wbond.net/sublime_packages/sftp][SFTP package]]. There's a similar (and free) package for [[https://marketplace.visualstudio.com/items?itemName=liximomo.sftp][VS Code]].

The canonical solution for Emacs is [[https://www.gnu.org/software/tramp/][TRAMP]]. It's pretty cool, but not suitable for my workflow. I want instant feedback when navigating the project with Projectile and searching all files using =ag=. TRAMP is slow as hell for these.

A possible solution is to sync files from local to remote using rsync and do it automatically when files change. Doing full folder sync is slow. Luckily, rsync has =--files-from= option. You can specify a list of files to sync. So, use [[https://github.com/emcrisostomo/fswatch][fswatch]] to watch changes, and run =rsync= for each changed file.

Thanks to [[https://www.alistairphillips.com/2018/09/05/file-sync-with-fswatch-and-rsync/][Alistair Phillips]], I didn't have to write the whole script myself. Here is what I got in =sync.sh=:

#+BEGIN_SRC bash
#!/usr/bin/env bash
rm --force /tmp/remote-server-rsync.txt
rm --force /tmp/remote-server-rsync-relative.txt

echo "Starting initial sync..."
rsync --verbose -azP --delete --exclude='.git/' --exclude='.DS_Store' --exclude='tmp/' . remote_user@XXX.XXX.XXX.XXX:/home/remote_user/hexlet
echo ""

echo "Watching..."

fswatch --exclude=".git" --batch-marker=EOF -xn . | while read file event; do
    if [ $file = "EOF" ]; then
       printf "%s\n"  "${list[@]}" > /tmp/remote-server-rsync.txt
       sed -e "s,/Users/rakhim/code/hexlet/,," /tmp/remote-server-rsync.txt > /tmp/remote-server-rsync-relative.txt
       echo "Beginning sync..."
       rsync --verbose --files-from=/tmp/remote-server-rsync-relative.txt . remote_user@XXX.XXX.XXX.XXX:/home/remote_user/hexlet
       echo "sync completed"
       echo "Watching..."
       list=()
    else
       list+=($file)
    fi
done
#+END_SRC

The workflow looks like this:

1. Run =./sync.sh=
2. That's it :-) Just edit files and save them as usual. It takes about a second to sync.
** DONE Make Firefox faster and nicer on macOS
CLOSED: [2018-10-01 Mon 13:53]
:PROPERTIES:
:EXPORT_FILE_NAME: improve-performance-of-firefox-on-macos
:END:

I'm trying Firefox as my primary browser on all devices. It has some great features like [[https://support.mozilla.org/en-US/kb/containers][Multi-Account containers]] in addition to being a non-Google product, which is an increasingly rare feature on the web nowadays.

Firefox on macOS is somewhat sluggish at the moment. If you try the current stable version 62 or current beta version 63, you'll notice some lags and general slow response time for even the simplest tasks like changing tabs.

Mozilla will probably fix these issues in the upcoming releases. Meanwhile, I found the following steps improve the performance significantly.

*** Download Firefox 63 or higher

As of today (October 1, 2018), stable release version is 62. Version 63 is currently in beta, and I recommend using it today. It's very robust, I haven't had any problems with it. There are some important [[https://www.mozilla.org/en-US/firefox/63.0beta/releasenotes/][performance improvements in it]].

You can also try Firefox Nightly, it is currently version 64 on the dark side. Nightly is an unstable testing and development platform. By default, Nightly sends data to Mozilla — and sometimes their partners. There are some rough edges, I wouldn't recommend it for daily browsing.

*** Disable animations

By default Firefox has lots of animations. I find them unnecessary and distracting, but more importantly, they contribute to the general sluggishness.

Go to =about:config= in the address bar. Search for =animate= and set at least  =cosmeticAnimations= to =false=.

Fullscreen transition takes 0.2 seconds both ways. Make them instant by setting the following to =0 0=:

- =full-screen-api.transition-duration.enter=
- =full-screen-api.transition-duration.leave=

*** Disable Pocket

Firefox embedded Pocket into the browser. A questionable move, but it's easy to disable (unless you use it, of course). Set =extensions.pocket.enabled= to =false=.

*** Other stuff

These are not related to performance, but can make your Firefox experience a bit nicer.

Set to true:

- =modalHighlight= highlight all the search results.
- =browser.tabs.closeTabByDblclick= close tab by double-clicking on it.
- =abs.multiselect= shift-click on tabs to select a group of tabs and do something with them (for example, detach from window).
- =insecure_connection_text.enabled= write "Not Secure" in the address bar of non-https pages (like Chrome does). Additionally, enable a broken padlock icon with =security.insecure_connection_icon.enabled=.

Minor things:

- =general.smoothScroll.mouseWheel.durationMaxMS= set =200= to make scrolling speed similar to Chrome.
- =geo.enabled= set to =false= to disable geolocation.
- =extensions.screenshots.disabled= set to =true= to disable the screenshot extension. It's actually pretty handy, check it out before disabling.
** DONE The price of complexity
   CLOSED: [2019-11-20 Wed 12:48]
:PROPERTIES:
:EXPORT_FILE_NAME: the-price-of-complexity
:END:
Computer programmers often talk about tackling complexity, yet they thrive on complexity. I believe tech people experience a constant dilemma: on one hand, we want things to be simple and straightforward; on the other hand we love complex structures and engineering marvels.

I think about this today as I'm performing some cleanup work on my blog. It runs on Hugo, content is written in Org mode, code is published on Github and the final website is deployed to Netlify. That's a lot of moving parts, and, honestly, it feels excessive. Yet I love this setup.

Lately I've been trying to be conscious and mindful about the price my mind pays for all this complexity. I'm not a good programmer by any means, so your mileage may vary, but it takes an enormous amount of mental energy for me to re-understand something I already figured out before. Take Hugo for example, a flexible and powerful static website generator. Jekyll, which I used before Hugo, is complex, too, but Hugo drives me crazy sometimes. It's a multi-layered system of interconnected logic and it took me a whole day to [[/2018/09/moved-from-jekyll-to-hugo-and-ox-hugo/][move from Jekyll]].

/*Intermission*: I just spent 5 minutes trying to create a relative hyperlink to that other blog post, and couldn't. It took me a while to realize I'm in Org mode now, not in Markdown, my syntax was wrong. You know what a Wordpress or Ghost user would've done? Clicked a link button in their rich WYSIWYG editor and had finished the blog post by this time already./

Every time I need to make some changes to the setup — fix layouts, add pages, refactor templates — I feel completely lost. It happens rare enough for my brain to forget the structure and conventions. And this is the case for a dozen of software projects I touch throughout the year.

This feeling of being lost is similar to un-pausing a video game that was on pause for 6 months. I know I've been into this, but right now I don't even know what buttons to press.

There are ways to fight this. One is to dramatically reduce complexity in the first place, maybe even sacrifice some of the features. My setup can be technically replaced by a bunch of HTML files, for example. Or switch to a "normal" thing like Ghost or Wordpress. Oh, and don't host them yourself, but pay someone to take care of it.

Another way is to somehow capture the knowledge for easy retrieval. My problem with Hugo is that I rarely touch it, so I forget. I should at least add a README file for myself, explaining the current setup and structure. Keeping documentation in sync with code is another problem, sigh...

So far, I only know one good way of solving this: teach. I should just make a course about Hugo on Codexpanse, that'll force me to really understand it and devise a good mental model.
** DONE Pocket App fails silently
CLOSED: [2019-11-21 Thu 09:31]
:PROPERTIES:
:EXPORT_FILE_NAME: pocket-app-fails-silently
:END:

[[http://getpocket.com/][Pocket]] is a popular "read later" app. People generally recommend it, and I haven't heard many complains about it. But in my experience, Pocket fails, and does it in the worst possible way.

Pocket repeatedly omits portions of pages. Here are a few examples from my queue — try adding them to your Pocket to verify the problem:

1. [[https://praxis.fortelabs.co/the-p-a-r-a-method-a-universal-system-for-organizing-digital-information-75a9da8bfb37/][This link]]: 11 images omitted.
2. [[https://char.gd/blog/2018/surface-go-is-proof-that-every-computer-needs-lte][This link]]: The last paragraph and all images omitted.
3. [[https://www.arnavion.dev/blog/2019-10-20-local-linux-user-tries-freebsd/][This link]]: First 50% of the article omitted.

Of course, parsing pages and extracting information isn't an easy task, and occasional hiccups are to be expected. The only reason I'm bringing this up is that, at least in my case, a significant amount of links end up problematic. Instapaper, a popular alternative to Pocket, doesn't have these issues on such scale.

The worst part of this is that you might not even notice something is missing, but end up thinking the article had a weird start (you missed the intro paragraph), or ends abruptly, or could use some images. Pocket delivers a poorly retold story.

Pocket also fails (non silently, that is) to process seemingly simple pages. For example, it couldn't pocket-ify  [[http://www.structuredprocrastination.com/][this page about Structured Procrastination]]. Yes, there are HTML validation errors, but both Instapaper and Safari's Reader mode render the simplified version perfectly fine.

This isn't new: I've been coming back to Pocket roughly every year in the past 10 years, and it's always like that. It's owned my Mozilla now, and even has a paid plan, yet Pocket fails at its main task.

I recommend to avoid Pocket.
** TODO Quick and dirty git push
:PROPERTIES:
:EXPORT_FILE_NAME: quick-and-dirty-git-push
:END:
Very often, all I need from git is to stage all changes, commit them and push to master. I've made two scripts for this. One in bash:

#+BEGIN_SRC bash
gitapush() {
  if [ $# -eq 0 ];
  then
    echo "Enter message: "
    read message
  else
    message=$1
  fi

  if [ -z "$message" ];
  then
    message=$(date +%d-%b-%H:%M)
  fi

  git add .
  git commit -m "$message"
  git push origin master
}
#+END_SRC

=gitapush= stands for "git all push" (I guess), and it's pretty dumb:

1. If argument is provided, use it as message, commit and push (e.g. =gitapush fix x=)
2. If argument isn't provided, as for a message.
   1. If a message was entered, commit and push.
   2. If not, generate a message from current date, commit and push.

To achieve a similar thing in Emacs, I use magit:

#+BEGIN_SRC emacs-lisp
(defun my-magit-stage-all-and-commit-and-push () (interactive)
       (let ((m (read-string "Commit message: ")))
         (unless (string= "" m)
           (magit-stage-modified)
           (magit-call-git "commit" "-m" m)
           (magit-call-git "push" "origin" "master"))))

(global-set-key (kbd "s-G") 'my-magit-stage-all-and-commit-and-push)
#+END_SRC

This one doesn't generate an automatic commit message, though. I bound it to =Cmd+Shift+G=, because =Cmd+G= is how I open the magit status pane.

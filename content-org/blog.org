#+TITLE: Posts
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: blog
#+SEQ_TODO: TODO DRAFT DONE
#+PROPERTY: header-args :eval never-export

#+OPTIONS: creator:t toc:nil

* Blog
** DONE Moved from Jekyll to Hugo and ox-hugo
CLOSED: [2018-09-03 Mon 17:13]
:PROPERTIES:
:EXPORT_FILE_NAME: moved-from-jekyll-to-hugo-and-ox-hugo
:END:

I have changed the setup for this blog from Jekyll + Github to Hugo + ox-hugo + Netlify. The main goal was to be able to write blog posts from within Emacs and reduce as much traction as possible. Also, Org mode is much more comfortable to write in compared to any Markdown editor I've tried.

*** Previous setup

I've been using Jekyll and Github pages for a long time, and it was generally a good experience. I don't have big complaints about Jekyll. It can be a bit clunky when it comes to things like tags, but I don't use them anyway. My [[https://rakh.im/][Russian blog]] is still powered by it. One thing that is never fun — the need to manage Ruby environment and dependencies. Some people prefer to encapsulate everything into Docker containers, and I've tried that with Jekyll as well, but the overhead complexity is not worth it.

I was using Sublime Text or sometimes iA writer to write posts. The whole process was full of small steps that added friction. I fully acknowledge that this sounds like "the tools stopped me from being a prolific blogger, if only I had better tools" fallacy.

This is how it looked like for the most part:

1. Go to iTerm, navigate to my blog directory and start Jekyll server.
2. Open the project in Sublime.
3. Create a new Markdown file with a correct name (e.g. =2018-01-11-be_bored.md=). I have a bash script to quickly create a new file with some front-matter inserted by default.
4. Go to browser, reload page, open post.
5. Write Markdown in Sublime, reload page to see result.
6. Push to Github when ready.

Sometimes thing go bad and Github build fails. There is no clarification, and on rare occasions I had to contact support to find out the actual build error output. GitHub's support is excellent, but this process is no fun.

*** New setup

Now I use [[https://gohugo.io/][Hugo]] static site generator, but don't write Markdown myself. I write in Org mode (I talked about it in [[http://emacscast.rakhim.org/episode/754222a0-714c-41b6-9203-8d0dc0d6210f][EmacsCast episode 2]]) and use [[https://ox-hugo.scripter.co/][ox-hugo]] to generate Markdown files for Hugo to then generate static HTML. Yeah, seems like too many moving parts for the sake of the simplest page possible, but it works remarkably well and — worst case scenario — if Emacs or Org or ox-hugo go bad, I can go back to essentially the same process as before.

This is how it looks like:

1. Go to Emacs, open my blog project (one second worth of key strokes thanks to [[https://github.com/bbatsov/projectile][Projectile]] and [[https://github.com/emacs-helm/helm][Helm]], which were also mentioned in [[http://emacscast.rakhim.org/episode/754222a0-714c-41b6-9203-8d0dc0d6210f][EmacsCast episode 2]]).
2. Open shell buffer, start Hugo server, open browser.
3. Write new post. All posts are stored in a single Org file, so I don't need to create new files. The name of the final Markdown file is generated automatically from the post title.
4. Save Org file. New post is generated and browser is redirected or refreshed.
5. When ready, change the Org status of the section to *DONE*.
6. Use Magit or a single Bash script to add, commit and push files to Github.
7. Netlify picks up the commit and builds the pages. If something goes wrong, I can see the detailed build logs.

*[[/images/posts/oxhugo.png]]*

And with Org capture I can create a new draft from anywhere in Emacs with two key strokes.

*** Nice things about Hugo

There are several small things that make Hugo nicer than Jekyll for me:

1. With =hugo server -D --navigateToChanged= the browser navigates to the changed file automatically and refreshes the page on each change. No need to refresh the page manually! Instant Markdown preview.
2. Hugo is distributed via Homebrew, and I don't need to care about Ruby environment and dependencies like I had to with Jekyll.
3. I have several sites, and Hugo randomizes the port if the default port is in use. A tiny nice detail.
4. It seems much faster than Jekyll.

*** Nice things about Org and ox-hugo

While this transition was mainly performed due to workcrastination, I'm pretty happy with the results. Hugo itself wouldn't be the reason to switch, it's the combination of Org + ox-hugo + hugo that makes it all worth the hassle.

Writing in Org is arguably a more pleasant experience compared to Markdown. Being able to integrate blogging into the same program that is used for planning, programming and long-form writing is very nice.

The whole blog setup, including this custom theme is available on [[https://github.com/freetonik/rakhim.org][Github]].
** DONE I no longer care about og tags, twitter cards, etc.
CLOSED: [2018-09-04 Tue 15:44]
:PROPERTIES:
:EXPORT_FILE_NAME: no-more-og-crap
:END:

Enough.

Facebook, Twitter and other social networks have their own markup formats that "enable any web page to become a rich object in a social graph". For the most part it means that if you want to make your link look nice when people share it, you have to set some meta tags.

#+BEGIN_SRC html
<meta property="og:title" content="The Wonderful" />
<meta property="og:type" content="article" />
<meta property="og:image" content="/images/cover.jpg" />
#+END_SRC

This is a noble idea in the abstract, and one more attempt at creating semantic web, since you can not only specify titles and cover images for shared links, but detailed meta information as well, like the type of content, authors, dates, etc. Facebook is a for-profit company that just made all the decisions and created their own protocol. It's not open - there is no way for the public to participate in its development, unlike W3C's work. The only reason people are using this protocol is because often their livelihood depends on the amount of traffic that comes from Facebook. Of course they'd like to make their links look good in Facebook posts!

Some other social media sites support og tags with certain quirks. Like, you provide a cover image, but different sites crop them differently because they want consistent media proportions on their side. So, now your content looks link still looks like garbage and #webdesign Medium blog posts are full of "how to make your link look awesome in LinkedIn in 2018" tutorials.

The sheer amount of resources the industry pours into made up problems like that...

I decided not to care about this for my personal projects anymore. If someone wouldn't click on a link to my site because the link looks less attractive than a flashy colorful image, so be it.
** DONE Personal finances and controlled anarchy
CLOSED: [2018-09-07 Fri 12:31]
:PROPERTIES:
:EXPORT_FILE_NAME: personal-finances-and-controlled-anarchy
:END:

Most of my life, I didn't have much money. I was born in the 90s in a tiny Kazakh town, and nobody had a job there, it seemed. USSR just collapsed and my parents were trying to make ends meet in a constant hustle.

That life defined my relationship with money and wealth for years to come. Every time I had to buy coffee, I was thinking "is it worth it?.. Maybe I shouldn't". In restaurants and cafes I was looking at prices first, then at meals. "Hmm, this cheap pasta looks so attractive! Ooh, I bet this expensive steak is not that good".

"You know what? I'll just buy this coffee and not buy that iPhone game I wanted to buy. Yeah, perfect! Now I'm calm and safe!"

After graduating and starting working full time I decided to follow a popular advice: budget everything. I started using an excellent app called [YNAB](https://www.youneedabudget.com/) — You Need a Budget. Not only it allows you to track all your expenses and plan ahead, it also comes with a philosophy, a set of rules and ideas to help you navigate your personal finance world.

First things first: save one month worth of expenses and never let your account get dry. The idea is to be spending money that is at least 30 days old. So, if you got your salary on February 1st, you will spend this money in March or later, but not in February. This way you never get into «I need some money until my next salary».

Next, give every dollar a job. This means that each dollar you get — you decide what it's for. I have regular expenses like rent, phone fees, groceries etc. Some amount of money MUST go there. But I also have other categories, like "Books" or "Electronics" or "Travel". And if I want to buy a book or go for a vacation, I have to have enough money saved in that category.

Putting money into savings account is another type of a job.

YNAB allows you to assign every dollar a particular job. It actually encourages you to keep exactly ZERO cents unassigned! You feel like a finance director of a small enterprise. Serious business!

This way you know exactly whether you can afford something. And you never have to guess "hmm, if I buy this laptop now, will I be okay with the rent?..".

*[[/images/posts/ynab.jpg]]*
/YNAB classic app screenshot (not mine)/

Another YNAB rule is to budget in detail and ahead. "Make your money boring" is their slogan for it. For every bill to come or an unexpected expense to surprise you, you'll have money waiting.

For example, I was putting some money into "Car repair" category each month, even though for the most part my car didn't require any repair. But when the AC compressor suddenly died in the middle of the hot German summer vacation, I knew I don't have to worry.

Basically, save money for Christmas all year long, not just in December.

One more YNAB rule is to "Roll With The Punches". When you overspend in a budget category, just adjust. No guilt necessary! It was easy for me to justify another gadget when I under-spent in some other categories.

I was an everyday user of YNAB for 7 years. The app itself is 14 years old and it has a great following and a nice community around it. It helped me *tremendously*! A huge amount of stress just went away, I was on top of my finances, I knew exactly what's happening and how much money I'm getting and spending. When my girlfriend moved in with me and we started sharing our budgets, YNAB was able to accommodate it. I just added another bank account in the settings. In total, I was controlling multiple bank accounts (including "cash" account) and cards, several sources of income and tens of budgeting categories.

It was great.

So, why did I stop?

Don't get me wrong: an app and a method like that makes a HUGE difference. I will never go back to having no control and no knowledge over my finances, but I still had lots of stress points.

First, it took a lot of time and energy to maintain the system. I had to put all the expenses precisely, every purchase, every fee, including cash purchases. The system makes sense only if you're precise and 100% accurate.

Card purchases overseas were especially painful. They often change over time, like, you buy something off Amazon, and they charge you with currency conversion, and after a week or so an "adjustment" charge is made silently (since the exchange rate changed a bit). You have to track it all and "consolidate" your accounts every month.

Or you just forget what that $0.99 supermarket purchase was three weeks ago. Was it chocolate, so, groceries category? Or a LAN cable, so, electronics category? Does it really matter? It's just 99 cents, so… whatever, let it be groceries.

Another problem was — I still had some stress over money. Less than before, but still. This "roll with the punches" rule is nice and liberating, but sometimes it seemed like I was just abusing the system. I want a new gadget, so, I'll just transfer $100 from "car repair" and compensate next month by spending less in every category. It'll be just fine!

It takes lots of energy not only to maintain the system, but to keep disciplined. I'm not that good at it.

A year ago I decided to deliberately simplify my life. Automate everything I can, ignore more stuff, eliminate pain points and minimize the mental energy requirements on everything except first-order things.

First-order things are the actual things I want to spend time on, the things that are intrinsically important for me. Money is a tool, so, it's at most second-order. It allows for the first-order things, but it doesn't have intrinsic value itself.

So I ditched YNAB and budgeting in general.

This was the most liberating moment I had in some time!

I call my new system "controlled anarchy", and it's pretty simple.

Every time our family gets salary payment or other income, I distribute it between three bank accounts:

1. *Monthly bills.* This account pays all the bills, from rent to Netflix. It has its own debit card, so I don't really see the purchases very often. I know exactly how much money is spent, though, since all the expenses here are static. Like with YNAB philosophy, this account has 2 months of expenses all the time, so it never gets dry. (I am actually increasing this account to 6 months of expenses so it will act as the emergency fund. Bad things happen — we have 6 months to figure things out).
2. *Savings.*. Yup, just savings. At least 33% of all the income is saved. A portion of it is invested in mutual funds for the long term.
3. *Everyday spending.* The rest is free! This is the key — I don't have to plan or to calculate or track anything. This account is the free money we can spend however we want! (Some of it goes to groceries, but the rest is truly free).

The Everyday spending account rarely gets to zero, and we never move money away from it. So, it actually grows gradually, and if we don't spend it all one month, we get even more free money next month!

The goal is to eliminate guilt and uncertainty about purchases. You want that new thing? Just buy it if there's enough money. Not enough in Everyday spending? Well, sorry, you can't buy it. But hey — feel free to buy whatever — spend it all away!

Oh, man, this made our lives so much easier.

The "controlled anarchy" system lacks the precision of the previous one, but requires no time and energy to maintain. All the payments and transfers are automatic, it's like we're kids and a wise parent manages our spending money :)

This is what I call simplification: less decision-making means more energy for the truly important things.

Now, if you don't do any sort of budgeting and don't really control your money, I'm not sure going into "controlled anarchy" right away is a good idea. It seems like it's alright, but maybe you should try real detailed budgeting first, maybe for a year or so, just so that you understand what's going on, where money goes to.
** DONE Keyboard fanaticism
CLOSED: [2018-09-10 Mon 16:54]
:PROPERTIES:
:EXPORT_FILE_NAME: keyboard-fanaticism
:END:

I've been reading [[https://sites.google.com/site/steveyegge2/effective-emacs][an article about Emacs]], and this paragraph had nailed me right into the soul:

#+BEGIN_QUOTE
IDE users spend most of their time fumbling around with the mouse. They wouldn't dream of doing it any other way, but they don't realize how inefficient their motions are.

...

Whenever you need to jump the cursor backward or forward more than about 5 lines, and you can see the target location, you should be using i-search.
...

Let your eye defocus slightly and take in the whole paragraph or region around the target point, and choose a word that looks reasonably unique or easy to type. Then i-search for it to navigate to it. You may need to hit Ctrl-r or Ctrl-s repeatedly if your anchor word turns out not to be unique.
#+END_QUOTE

This is a common rhetoric: use keyboard only, don't you dare to use the mouse — it's so inefficient!

The scenario in question is simple: you have to move the cursor to some position you see on the screen. Instead of moving your hand to the mouse to move the pointer, the author suggests the following algorithm:

1. Determine if the place you need to go to is before or after current position. This is non-zero mental work.
2. Take a look around that point and "choose a word that looks reasonably unique". Perform more mental work of determining which word is unique enough.
3. If the target is before the current position, use =Ctrl+s=. If it's after, use =Ctrl+r=. This is more or less automatic, but still required mental work of maintaining the mapping between direction and binding.
4. If your judgement of the uniqueness wasn't good enough, you'll end up somewhere else. Possibly, in a completely different section of the document. Additional mental work — you have to realize what happened, disoriented. Keep hitting =Ctrl+s= or =Ctrl+r=. And you have to keep scanning the surroundings every time you jump until you get where you want.
5. Okay, you're there! But remember, you've been jumping to a place *near* the target, so now you have to move a bit more — by word or by character.

#+BEGIN_QUOTE
Mastering it simply requires that you do it repeatedly until your fingers do it "automatically". Emacs eventually becomes like an extension of your body, and you'll be performing hundreds of different keystrokes and mini-techniques like this one without thinking about them.
#+END_QUOTE

While I understand the premise completely, and I occasionally use the same technique, I can’t help but think an advice like that rarely takes into account the trade-off. Yes, moving your hand to the mouse takes time, but it’s not uncommon that the time required is actually *less* than multi key multi step keybinding. Instead of spending a second, two motions and a single click the user is advised to analyze text, make several decisions and hit multiple keys, which might or might not be enough. But hey, you didn't leave the home row, so, win, I guess?..

I'm not defending the mouse here, but I do think there are occasions where using the mouse is just better *for me*. Too often these articles are trying to make you feel like an unintelligent cave man for daring to use the "device of IDE users".

Also, Emacs packages like [[https://github.com/abo-abo/avy][avy]] or [[https://github.com/hlissner/evil-snipe][evil-snipe]] make jumping to visible text much simpler and cost less mentally.

The vast sea of discussions and advice about programming tools and especially text editing is full of opinions, approaches and cult-like repeated revelations. Often, the loud sounds of the echo chamber make it difficult to stop for a moment and evaluate something yourself. But please do try.

It's easy to be indoctrinated.
** DONE A Simple Introduction to Proof by Contradiction :featured:
CLOSED: [2018-09-12 Wed 17:49]
:PROPERTIES:
:EXPORT_FILE_NAME: proof-by-contradiction
:END:

In mathematics, a theorem is a true statement, but the mathematician is expected to be able to prove it rather than take it on faith. The proof is a sequence of mathematical statements, a path from some basic truth to the desired outcome. An impeccable argument, if you will.

One of the basic techniques is proof by contradiction. Here is the idea:

1. Assume the statement is false.
2. Derive a contradiction, a paradox, something that doesn't make sense. This will mean that the statement cannot possibly be false, therefore it's true.

When I first saw this formal technique, it puzzled me. It didn't seem to be valid: alright, assuming something is false leads to a paradox, so what? We haven't proven that assuming it's true doesn't lead to another paradox! Or even the same paradox, for that matter. What I failed to understand conceptually is that a statement is a binary thing: it's either true or untrue. Nothing in between. So, if one can definitely declare "X is not false", then no other options are left: "X must be true".

*** Direct proof

To demonstrate this, let's first use another technique of a /direct proof/ so that we have something to work with.

*Theorem 1.* If \(n\) is an odd positive integer, then $n^2$ is odd.

A /direct proof/ just goes head in, trying to see what the statement means if we kinda play with it.

*Proof.* An odd positive integer can be written as \( n = 2k + 1 \), since something like \( 2k \) is even and adding 1 makes it definitely odd. We're interested in what odd squared looks like, so let's square this definition:

$$ n^2 = (2k + 1)^2 = $$
$$4k^2 + 4k + 1 = $$
$$ 2(2k^2 + 2k) + 1 $$

So, we have this final formula \( 2(2k^2 + 2k) + 1 \) and it follows the pattern of \( 2k + 1 \). This means it's odd! We have a proof. ■

This theorem is based on an idea that numbers described as \( 2k + 1 \) are definitely odd. This might be another theorem that requires another proof, and that proof might be based on some other theorems. The general idea of mathematics is that if you follow any theorem to the very beginning, you'll meet the fundamental axioms, the basis of everything.

Now that we have this proven theorem in our arsenal, let's take a look at another theorem and prove it by contradiction.

*** Proof by contradiction

*Theorem 2.* \(n\) is a positive integer. If \( n^2 \) is even, then $n$ is even.

We may try to construct another direct proof, but creating paradoxes is much more fun!

*Proof.* Let's assume that \(n^2\) is even, *but $n$ is odd*. This is the opposite of what we want, and we will show that this scenario is impossible.

$n$ is odd, and from Theorem 1 we know that $n^2$ must be odd. This doesn't make sense! Our assumption and our conclusion are the opposite. This is a paradox, so the assumption was wrong. Meaning, the idea "\(n^2\) is even, but $n$ is odd" is false. Therefore, the idea "\(n^2\) is even, $n$ is even" is true.■

*** Famous irrational \( \sqrt{2} \)

*Theorem 3.* \( \sqrt{2} \) is irrational.

Woah, this is... different. In the first two theorems we had formulas, something to play with, something physical. This now is just an idea, so how would we even start?

Let's start with a definition.

#+BEGIN_QUOTE
In mathematics, the irrational numbers are all the real numbers which are not rational numbers.[fn:1]
#+END_QUOTE

Doesn't seem helpful, but let's continue. What are rational numbers then? Are they some reasonable beings who make optimal decisions all the time?

#+BEGIN_QUOTE
A rational number is any number that can be expressed as the fraction \(\frac{p}{q}\) of two integers.[fn:2]
#+END_QUOTE

Oh! They are rational because they are /ratios/!

Just to make things super clear, let's dig one more step and make sure we understand integers.

#+BEGIN_QUOTE
An integer (from the Latin /integer/ meaning "whole") is a number that can be written without a fractional component. For example, 21, 4, 0, and −2048 are integers, while \(9.75\), \( 5\frac{1}{2} \) and \( \sqrt{2} \) are not.[fn:3]
#+END_QUOTE

Combining these things, we can construct a comprehensive definition of an irrational number: it's a number that cannot be expressed as the fraction of two whole numbers.

Now, let's apply this to Theorem 3 so that it has some meat:

*Theorem 3.* \( \sqrt{2} \) cannot be expressed as \( \frac{p}{q} \), where $p$ and $q$ are integers.

Alright, now there is something to play with!

*Proof.* Start by assuming the opposite -- \( \sqrt{2} \) is rational. This means it can be written as a fraction of two integers:

$$ \sqrt{2} = \frac{p}{q}\ $$

We can assume that $p$ and $q$ are not *both* even, because if they are, we can reduce them by dividing both by a common factor (like, for example, \( \frac{8}{10}\ \) should be reduced to \( \frac{4}{5}\ \)). In other words, if they are both even, reduce them until at least one is odd and no further reductions are possible.

Now, let's square the square root:

$$ (\sqrt{2})^2 = \frac{p^2}{q^2}\ $$

$$ 2 = \frac{p^2}{q^2}\ $$

$$ p^2 = 2q^2 $$

Remember, something like $2k + 1$ is odd, and $2k$ is even. Here we see this pattern: $p^2 = 2q^2$, which means that $p^2$ is even (it consists of /two/ things).

Then, using Theorem 2, we can say that $p$ is even as well, which means we can write $p$ as $p = 2k$. So:

$$ 2q^2 = p^2 = (2k)^2 $$

$$ 2q^2 = 4k^2 $$

Divide both by two:

$$ q^2 = 2k^2 $$

So, $q^2$ is even. By the same Theorem 2 it follows that $q$ is even.

Let's summarize the two conclusions:

1. $p$ is even.
2. $q$ is even.

Wait... We made sure that not both $p$ and $q$ are even before starting this whole thing! We made sure to reduce them until at least one is odd, but then, by applying Theorem 2, we ended up with two even numbers. This is impossible, so the idea that "$\sqrt{2}$ is rational" is not true.

Therefore, $\sqrt{2}$ is irrational.■

/P.S. I often use proof by contradiction in real life by arguing that, for example, not eating the whole bucket of ice cream at once will lead to a paradox that endangers the whole fabric of space-time. It works for me, but your mileage my vary./

[fn:1] https://en.wikipedia.org/wiki/Irrational_number
[fn:2] https://en.wikipedia.org/wiki/Rational_number
[fn:3] https://en.wikipedia.org/wiki/Integer
** DONE Dumb Down the Context Until the Problem Goes Away :featured:
CLOSED: [2018-09-14 Fri 21:10]
:PROPERTIES:
:EXPORT_FILE_NAME: dumb-down-the-context-until-the-problem-goes-away
:END:

At work we use SCSS and HAML, so I rarely write pure HTML and CSS there. But for small side projects and my personal blog I tend to stick with the simplest (and dumbest) possible tools. This week I was working on a refreshed look for this blog. Being a good modern man, I tried to stick with =em= or =rem= for sizing and typography.

Using =em= means adding state to your specs, and I don't like this. Looking at a particular element, it can be impossible to understand what =em= means. So =rem= it is.

The value =rem= is "equal to the computed value of font-size on the root element", so starting with this:

#+BEGIN_SRC
html {
  font-size: 21px;
}
#+END_SRC

we suppose to get a universal and stable variable. =10rem= now means =210px=. Cool? Not so much.

I wrote a simple media query to make headers smaller on narrow screens:

#+BEGIN_SRC
@media (max-width: 34rem) {
  h1 {
    font-size: 2.369rem;
  }
}
#+END_SRC

But it doesn't work at the specified break point of =34rem = 714px=. Turns out that in media queries =rem= means "initial value of font-size", as per spec[fn:1]. It's =16px= in most browsers.

You have two lines of code near one another, and the same symbol means different things. Check out this [[https://fvsch.com/browser-bugs/rem-mediaquery/][demonstration]]. And you dare to complain about mutations in your imperative programming language!

[[https://adamwathan.me/dont-use-em-for-media-queries/][Using =em='s in media queries brings problems]] as well. So, in the end, pixels are the only units that behave consistently across all browsers and don't add hidden qualities to your styles.

I then thought okay, I can get around this problem by using =calc=, which seems to be supported in all browsers nowadays.  Nope, it doesn't work in media queries.

The first thought that came after that is almost a reflex for many web developers alike: just use some tools on top of this ugly and inconsistent language!

A pre-compiler like SCSS provides variables and calculations and other sweet features. It can seamlessly generate final CSS if you enable a watcher, or even better, set up something like Gulp or Webpack (oh, god). But then it'll be kind of difficult to use the web inspector in the browser, since it shows the final CSS, but I never work with it directly.

Oh, no worries, you can generate source maps for SASS/SCSS. Magic[fn:2]!

But wait... While this solves my problem, it adds a tremendous amount of complexity. Is it worth it? Clearly, not in my case, but for a huges project like Hexlet at my main job it clearly does. Where is the threshold? How does one know when it's worth to invest into a set of new abstractions that comes with their own quirks and problems?

It's a difficult question, but for me and my small projects I found it important to remind myself: resist complexity at all costs, resist adding new things into the system. If my problem asks for a solution that involves additional tools or systems, first and foremost consider dumbing the whole thing down so that the problem goes away. By regressing to pixels, which are so "not modern", I managed to avoid a whole bag of cruft being put on top of this primitive project. The system became dumber. It's a win for me.

This is a weak example, I agree, so let me provide another one. Few years ago I needed to launch a small wiki site. Many popular wiki engines (like MediaWiki) are way too complex and feature-rich, so I looked for simpler alternatives. I found a nice Ruby library[fn:3] and spend few hours setting it up, providing custom templates and styles. I was happy with the result, but then I found myself daunted by the worst part: deploy and maintenance.

Of course, setting up a server by hand is a no-no, so I had to write an Ansible recipe for Ubuntu Rails environment. Accidental complexity involved in this problem became so large I started forgetting what I was trying to achieve.

It took me some time to realize that the primary audience for this wiki will actually be much more comfortable editing text directly via Git rather than fiddle with a web interface. And if it's hosted on GitHub, I don't have to worry about authorization and accounts. I still needed it to run on my domain with some specific HTML, so I just made a simple Jekyll site and provided links to quickly edit and send pull requests via GitHub.

I had problems associated with deployment and maintenance, and instead of adding tools as solutions, I dumbed the whole context so that the problems went away.

Note that these problems are often of accidental complexity type. Intrinsic, real problems don't surrender this easily.

If playing with lots of inter operating tools is fun, by all means go for it. As long as you /remember/ and /realize/ what is going on. Complexity is not inherently bad, it's just sort of cunning when you're not mindful.

[fn:1] https://www.w3.org/TR/css3-mediaqueries/
[fn:2] https://robots.thoughtbot.com/sass-source-maps-chrome-magic
[fn:3] https://github.com/gollum/gollum
